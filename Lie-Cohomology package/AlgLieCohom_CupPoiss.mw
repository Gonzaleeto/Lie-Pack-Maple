<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2016" minor="1"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true" UserProfileName="Perfil de Maple Predeterminado" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false">
</View-Properties>
<MapleNet-Properties prettyprint="3" warnlevel="3" preplot="" helpbrowser="standard" contextmenusize="automatic" displayprecision="-1" echo="1" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsafter="100" elisiondigitsbefore="100" plotdevice="inline" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsbefore="100" elisiontermsafter="100" screenwidth="79" indentamount="4" plotoutput="terminal" screenpixelheight="900" rtablesize="infinity" useclientjvm="true" labelwidth="20" postplot="" typesetting="standard" ansi="false" elisiondigitsthreshold="10000" showassumed="1" errorcursor="false" labelling="true" screenheight="25" prompt="&gt; " verboseproc="1" latexwidth="8.0" ShowLabels="true"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group hide-output="false" labelreference="L37" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">interface(rtablesize=infinity):
with(linalg):</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L38" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">with(LinearAlgebra):
with(combinat):
with(ArrayTools):</Text-field>
</Input>
</Group>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Cociente corregido</Text-field></Title>
<Group hide-input="false" hide-output="false" labelreference="L2137" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Cociente_corr := proc(listP, listQ):: list:
    local Coc_res:
    Coc_res:=[]:
    if nops(listQ) = 0 then:
       Coc_res := [seq(convert(v, list), v in listP)]:
    else:
       Coc_res := Cociente(listP,listQ):
    fi:
    return Coc_res:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2136" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=</Equation></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Rutinas Sobre Listas</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Igualdad de dos Listas</Font></Text-field></Title><Text-field style="Text" layout="Normal">Retorna si dos Vectores, array o listas son iguales
<Font opaque="true" background="[255,255,153]">Nota: Generalmente es para estructuras indexadas no tan grande
</Font>Para evitar el tema de incompatibilidad entre array o Vector, se convierte a list</Text-field><Text-field style="Text" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L3471" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">List_iguales := proc(E1,E2):: boolean:
local V1, V2 :: list:
   V1 := convert(E1, list):
   V2 := convert(E2, list):

   if V1 = V2 then return true else return false fi:
end proc:
</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Vectores Canonicos</Font></Text-field></Title>
<Group labelreference="L3474" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Canonicos := proc(n) local T,R,a,i,j:
T:=[];
for j from 1 to n do
    R:=[];
    for i from 1 to n do
      if i=j then a:=1 else a:=0 end if;
      R:=[op(R),a];
    od;
    T:=[op(T),R];
od;
T:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Remover una determinada posicion de una lista</Font></Text-field></Title><Text-field style="Text" foreground="[51,102,255]" layout="Normal"><Font foreground="[0,128,128]">Remueve determinada posicion en una lista</Font></Text-field>
<Group hide-output="false" labelreference="L3489" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Remove_Pos := proc(Lista::list  , pos::integer)::list:
    local AuxList:
    AuxList:=Lista:
    if pos&lt;=nops(AuxList) and pos&gt;0 then
       AuxList:=subsop(pos=NULL,AuxList):
    fi:
    return AuxList:
end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L3488" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Unir dos listas</Font></Text-field></Title>
<Group hide-output="false" labelreference="L3480" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Merge_2_list := proc(List1::list, List2::list)::list:
     return [seq(v, v in List1), seq(v, v in List2)]:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L3487" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L3484" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Merge_2_list_list := proc(List1, List2)::list:
     return [seq(convert(v,list), v in List1), seq(convert(v,list), v in List2)]:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Convertir una coleccion de Indexados a lista de lista</Font></Text-field></Title>
<Group hide-output="false" labelreference="L3476" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Convert_list := proc(Collec)::list:
     return [seq(convert(v,list), v in Collec)]:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Convertir una coleccion de Indexados a lista de Vector</Font></Text-field></Title>
<Group hide-output="false" labelreference="L3515" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Convert_Vector := proc(Collec):
     return [seq(convert(v,Vector[column]), v in Collec)]:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Busca un elemento en una lista</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Busca un elemento en una lista y en caso de encontrarlo devuelve la primera posicion donde aparece</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-input="false" hide-output="false" labelreference="L3481" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Find_Element := proc(Lista::list , element)::integer:
   local pos_result, index:
   index := 1:
   pos_result := -1:
   while index &lt;= nops(Lista) do:
      if Lista[index] = element then
          pos_result := index:
          index := nops(Lista)+1:
      else
          index:= index + 1:
      fi:        
   od:
   return pos_result:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Purgar de una lista un determinado elemento</Font></Text-field></Title><Text-field style="Text" layout="Normal"><Font foreground="[255,102,0]" encoding="UTF-8">Atenci\303\263n: Solo funciona para lista de lista de primitivos o lista de primitivos</Font></Text-field><Text-field style="Text" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L3482" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Purge_list_2_elem := proc(Lista::list, element)::list:
   local AuxList,i:
   AuxList:=Lista:
   i:=1:
   while i &lt;= nops(AuxList) do:
      if AuxList[i] = element then
          AuxList:=subsop(i=NULL,AuxList):
          
      fi: 
      i:=i+1:       
   od:
   return AuxList:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L3477" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L3479" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Purge_list_2_list := proc(Obj_l , element)::list:
   local AuxList,i:
   AuxList:=[seq(convert(v,list),v in Obj_l)]:
   i:=1:
   while i &lt;= nops(AuxList) do:
      if AuxList[i] = element then
          AuxList:=subsop(i=NULL,AuxList):
          
      fi: 
      i:=i+1:       
   od:
   return AuxList:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Construir combinaciones Formales lineales</Font></Text-field></Title>
<Group hide-input="false" hide-output="false" labelreference="L3486" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Combinacion_Formal:= proc(vec , Bas)
    local V_Formal,k,v:
    v:=0:
    for k from 1 to nops(vec) do: 
       v:=v+vec[k]*Bas[k]:
    od:
return v:
end proc:    
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L3483" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Combinaciones_Formales:= proc(List , Bas)
    local V_Formal,k,v,i:
    V_Formal:=[]:
    for k from 1 to nops(List) do: 
       v:=0:
       for i from 1 to nops(convert(List[1],list)) do:
           v:=v+List[k][i]*Bas[i]:
       od:
       V_Formal:=[op(V_Formal),v]:
    od: 
    V_Formal:
end proc:   </Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Multiplicar Matriz por lista y convertir a lista</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Metodo que multiplica una matriz con una lista y devuelve el resultado como lista</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]" encoding="UTF-8">Ser\303\241 de ayuda para calcular los productos de Clebsch-Gordan.</Font></Text-field><Text-field style="Text" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L3478" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Prod_list:=proc(Matriz,lista)::list:
   local res,lt:
   lt := convert(lista,Vector[column]):
   res := Matriz.lt:
   return convert(res,list):
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Multiplica parametro a una lista</Font></Text-field></Title>
<Group labelreference="L3494" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Prod_param_list := proc(par, Lista) local ii, L_aux:
   L_aux := Lista:
   for ii from 1 to nops(L_aux) do:
      L_aux[ii] := par*L_aux[ii]:
   od:
return L_aux:
end proc:</Text-field>
</Input>
</Group>
</Section>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Formatos de Base exterior y Tensores</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14" encoding="UTF-8">Base de V1\342\210\247V2 concatenada</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Rutina para realizar el producto alternante de dos listas, devolviendo como resultado una lista concatenada</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L2" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Basis_of_Alt := proc(List1::list, List2::list) :: list:<Font bold="false" foreground="[51,204,204]">
</Font>   local LAux:
   LAux := [seq(seq(cat(List1[i], List2[j]), j = i+1 .. nops(List2)), i = 1 .. nops(List1))]:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14" encoding="UTF-8">Base {x.y} del tensor V1\303\227V2</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Rutina para realizar el producto tensorial de dos listas, devolviendo como resultado una lista de sym.sym</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-input="false" hide-output="false" labelreference="L4" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Basis_of_TensorC := proc(List1::list, List2::list) ::list:<Font bold="false" foreground="[51,204,204]">
</Font>   local LAux:
   LAux:= [seq(seq(vv . ww, vv in List1), ww in List2)]:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14" encoding="UTF-8">Base {[x,y]} del tensor V1\303\227V2</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Rutina para realizar el producto tensorial de dos listas, devolviendo como resultado una lista de [xi,yj]</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L47" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Basis_of_TensorL := proc(List1::list , List2::list) ::list:<Font bold="false" foreground="[51,204,204]">
</Font>   local LAux:
   LAux:= [seq(seq([vv, ww], vv in List1), ww in List2)]
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Base Alternante de una lista</Font></Text-field></Title><Text-field style="Text" foreground="[255,153,0]" layout="Normal"><Font foreground="[255,153,0]">Rutina auxiliar para invocar en &quot;BasisAlt_of_list&quot;</Font></Text-field><Text-field style="Text" layout="Normal">Retorna la k-base alternante de una lista L = [v1,...vn] con formato de lista de listas. </Text-field><Text-field style="Text" layout="Normal">La lista de coordenadas (de longitud k) representa un vector base de la k-esima potencia exterior</Text-field><Text-field style="Text" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L3491" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">BasisAlt_of_L := proc(L :: list , k::integer) ::list:
   local LL,n,B,i:
   n:=nops(L):
   B:=BaseAlt(n,k): <Font bold="false" foreground="[0,128,128]"># Archivo AlgLieBasico.
</Font>   LL:=[]:
   for i from 1 to binomial(n,k) do:
     LL:=[op(LL),[seq(L[B[i][j]],j=1..k)]]:
   od:
   LL:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Base Alternante concatenada de una lista</Font></Text-field></Title><Text-field style="Text" layout="Normal">Retorna la k-base alternante de una lista L = [v1,...vn] con formato de lista de concatenaciones
Es necesario que L sea una base ordenada de un espacio vectorial y que n no sea mayor que la</Text-field><Text-field style="Text" layout="Normal">longitud de la lista, es decir, n &lt;= nops(L).</Text-field><Text-field style="Text" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L1185" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">BasisAlt_of_list := proc(L::list , k::integer) ::list: <Font bold="false"> 
    </Font>local Powerlist, AuxList, i,j, cat_word, aux_word:
    Powerlist := []:
    if k &lt;= nops(L) then:

       AuxList := BasisAlt_of_L(L,k):

       for i from 1 to nops(AuxList) do:
          cat_word := AuxList[i][1]:
          for j from 2 to nops(AuxList[i]) do:
             cat_word := cat( cat_word, AuxList[i][j]):
          od:
          Powerlist := [op(Powerlist), cat_word]:
       od:
    fi:
end proc:
</Text-field>
</Input>
</Group>
<Group hide-input="false" labelreference="L3493" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font opaque="true" background="[255,255,153]" foreground="[255,153,0]"># Ejempo de los dos metodos anteriores</Font>
BasisAlt_of_L([v1,v2,v3],2);
BasisAlt_of_list([v1,v2,v3],2);</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYqLUYjNiYtRiw2KC1JI21pR0YkNiVRI3YxRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEiLEYnL0Y6USdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGOC8lKXN0cmV0Y2h5R0ZELyUqc3ltbWV0cmljR0ZELyUobGFyZ2VvcEdGRC8lLm1vdmFibGVsaW1pdHNHRkQvJSdhY2NlbnRHRkQvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GMzYlUSN2MkYnRjZGOS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGREZARkAvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGPC1GIzYmLUYsNihGMkY8LUYzNiVRI3YzRidGNkY5RlpGZ25GQEZARmluRlxvRjwtRiM2Ji1GLDYoRldGPEZjb0ZaRmduRkBGQEZpbkZcb0ZaRmduRkBGQEZpbkZcbw==">NyU3JEkjdjFHNiJJI3YyR0YlNyRGJEkjdjNHRiU3JEYmRig=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYqLUkjbWlHRiQ2JVEldjF2MkYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RIixGJy9GNlEnbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjQvJSlzdHJldGNoeUdGQC8lKnN5bW1ldHJpY0dGQC8lKGxhcmdlb3BHRkAvJS5tb3ZhYmxlbGltaXRzR0ZALyUnYWNjZW50R0ZALyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictRi82JVEldjF2M0YnRjJGNUY4LUYvNiVRJXYydjNGJ0YyRjUvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRkBGPEY8LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYn">NyVJJXYxdjJHNiJJJXYxdjNHRiRJJXYydjNHRiQ=</Equation></Text-field>
</Output>
</Group>
</Section>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Rutinas sobre Strings</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Lista de permutaciones de un string</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Retorna la lista de todas las permutaciones de un string dado</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-input="false" hide-output="false" labelreference="L16" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Permutations_of_String := proc(s) local p,ss:
   ss := convert(s,string):
   seq( StringTools:-Permute(ss, p), p=combinat['permute'](length(ss))):
end proc:</Text-field>
</Input>
</Group>
</Section>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Rutinas para producto interior</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Producto interior sobre una lista de lista por un elemento e_ip</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto interior por e_ip sobre una Base de elementos Bas_List:
Suponga que la Base de V es [[1],[2],[3]] y queremos realizar el producto interior por [2]
de Bas_List := [[1,2],[1,3],[2,3]]. Entonces lo que tiene que devolver es [-[2],[3]] y para
considerar el tema de los signos vamos a devolver una lista [[[2],[3]],[-1,1]] </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L33" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Blist := proc(Bas_List::list , e_ip):: list:
   local Res_List, AuxList, Sign_List, pos_e, i:
   Res_List := []:
   AuxList := []:
   Sign_List := []:
   for i from 1 to nops(Bas_List) do:
       pos_e := Find_Element(Bas_List[i],e_ip):
       if pos_e &lt;&gt; -1 then
          if pos_e mod 2 = 0 then
             Sign_List:=[op(Sign_List),-1]:
          else 
             Sign_List:=[op(Sign_List),1]:
          fi:
             AuxList:=[op(AuxList),Remove_Pos(Bas_List[i],pos_e)]:
       fi:
   od:
   Res_List := [op(Res_List),AuxList,Sign_List]:
   return Res_List:
end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L35" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="B1 := [[1], [2], [3]];" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYxLUkjbWlHRiQ2JVEjQjFGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSomY29sb25lcTtGJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EsMC4yNzc3Nzc4ZW1GJy8lJ3JzcGFjZUdGTC1JKG1mZW5jZWRHRiQ2Ji1GIzYpLUZQNiYtRiM2JS1JI21uR0YkNiRRIjFGJ0Y5LyUrZXhlY3V0YWJsZUdGPUY5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRictRjY2LVEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSC9GS1EmMC4wZW1GJy9GTlEsMC4zMzMzMzMzZW1GJy1GUDYmLUYjNiUtRlk2JFEiMkYnRjlGZm5GOUY5RmhuRltvRl5vLUZQNiYtRiM2JS1GWTYkUSIzRidGOUZmbkY5RjlGaG5GW29GZm5GOUY5RmhuRltvLUY2Ni1RIjtGJ0Y5RjtGYW9GQEZCRkRGRkZIRmJvRk0tSSdtc3BhY2VHRiQ2Ji8lJ2hlaWdodEdRJjAuMGV4RicvJSZ3aWR0aEdGY28vJSZkZXB0aEdGXHEvJSpsaW5lYnJlYWtHUShuZXdsaW5lRictRiw2JVEjQjJGJ0YvRjJGNS1GUDYmLUYjNiktRlA2Ji1GIzYnRlhGXm9Gam9GZm5GOUY5RmhuRltvRl5vLUZQNiYtRiM2J0ZYRl5vRmFwRmZuRjlGOUZobkZbb0Zeby1GUDYmLUYjNidGam9GXm9GYXBGZm5GOUY5RmhuRltvRmZuRjlGOUZobkZbb0ZkcEZncC1GLDYlUS9JbnRfUHJvZF9CbGlzdEYnRi9GMi1GUDYkLUYjNihGZHFGXm8tRiw2JVEkc2VxRidGL0YyLUZQNiQtRiM2JkYrRmZvRmZuRjlGOUZmbkY5RjlGZHBGZm5GOQ==">Qyg+SSNCMUc2IjclNyMiIiI3IyIiIzcjIiIkRig+SSNCMkdGJTclNyRGKEYqNyRGKEYsNyRGKkYsRigtSS9JbnRfUHJvZF9CbGlzdEdGJTYkRi4tSSRzZXFHJSpwcm90ZWN0ZWRHNiMmRiQ2I0YqRig=</Equation></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEjQjFGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSp+JiM4Nzg4O35GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGTC1JKG1mZW5jZWRHRiQ2Ji1GIzYqLUZQNiYtRiM2Ji1JI21uR0YkNiRRIjFGJ0Y5LyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y9RjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1GNjYtUSIsRidGOUY7L0Y/RjFGQEZCRkRGRkZIRkovRk5RLDAuMzMzMzMzM2VtRictRlA2Ji1GIzYmLUZZNiRRIjJGJ0Y5RmZuRmluRjlGOUZbb0Zeb0Zhby1GUDYmLUYjNiYtRlk2JFEiM0YnRjlGZm5GaW5GOUY5RltvRl5vRmZuRmluRjlGOUZbb0Zeb0ZmbkZpbkY5">NyU3IyIiIjcjIiIjNyMiIiQ=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEjQjJGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSp+JiM4Nzg4O35GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGTC1JKG1mZW5jZWRHRiQ2Ji1GIzYqLUZQNiYtRiM2KC1JI21uR0YkNiRRIjFGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkhGSi9GTlEsMC4zMzMzMzMzZW1GJy1GWTYkUSIyRidGOS8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGZm4tRlA2Ji1GIzYoRlhGZm4tRlk2JFEiM0YnRjlGX29GYm9GOUY5RmRvRmdvRmZuLUZQNiYtRiM2KEZcb0ZmbkZecEZfb0Zib0Y5RjlGZG9GZ29GX29GYm9GOUY5RmRvRmdvRl9vRmJvRjk=">NyU3JCIiIiIiIzckRiQiIiQ3JEYlRic=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1GIzYmLUYsNiYtSSNtbkdGJDYkUSIxRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R1EmZmFsc2VGJ0Y6RjovJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRictSSNtb0dGJDYtUSIsRidGOi8lJmZlbmNlR0ZCLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRkIvJSpzeW1tZXRyaWNHRkIvJShsYXJnZW9wR0ZCLyUubW92YWJsZWxpbWl0c0dGQi8lJ2FjY2VudEdGQi8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnLUYjNiYtRiw2Ji1GNzYkUSIzRidGOkY9RkBGOkY6RkNGRkY9RkBGOkY6RkNGRkZJLUYjNiYtRiw2KC1GLDYlLUZKNi1RKiZ1bWludXMwO0YnRjpGTS9GUEZCRlJGVEZWRlhGWi9GZ25RLDAuMjIyMjIyMmVtRicvRmpuRl5wRjZGOkZJRjZGPUZARjpGOkZDRkZGPUZARjpGOkZDRkY=">NyQ3JDcjIiIiNyMiIiQ3JCEiIkYl</Equation></Text-field>
</Output>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Producto interior sobre un elemento (lista) por un elemento e_ip</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto interior por e_ip sobre un elemento de la base de V^k. </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">La estructura de datos de un elemento de la base de V^k es [x1,x2,....,xk] ( no son coordenadas ) respectivamente.</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-input="false" hide-output="false" labelreference="L40" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Ebasis := proc(E_Basis::list , e_ip):: list:
   local Res_List, AuxList, Sign_List, pos_e, i:
   Res_List := []:
   AuxList := []:
   Sign_List := 1:
   pos_e := Find_Element(E_Basis,e_ip):
   if pos_e &lt;&gt; -1 then
      if pos_e mod 2 = 0 then
         Sign_List:=-1:
      fi:
      AuxList:=Remove_Pos(E_Basis,pos_e):
   fi:
   Res_List := [op(Res_List),AuxList,Sign_List]:
   return Res_List:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14" encoding="UTF-8">Producto interior de un vector escrito en coordenadas en una base \316\233B1xB2 de \316\233VxW</Font></Text-field></Title><Text-field style="Text" underline="true" bold="true" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Int_Prod_Vec_coord_nt_lin</Font></Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field style="Text" underline="true" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" underline="true" bold="true" foreground="[0,128,128]">Int_Prod_Vec_coord_nt</Font></Text-field><Text-field style="Text" underline="true" foreground="[255,102,0]" size="14" layout="Normal"><Font size="12" underline="false" foreground="[255,102,0]">Ojo: este metodo funciona a partir de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==</Equation><Font size="12" underline="false" foreground="[255,102,0]">, k  &gt;= 2.</Font></Text-field><Text-field style="Text" underline="true" foreground="[255,102,0]" size="14" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" foreground="[0,128,128]">Realiza el producto interior por e_ip sobre un vector escrito en coordenadas con respecto a una base
de BT_ini = [list,list]. El resultado es un vector en coordenadas en la base BT_fin = [list,list].</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" underline="true" bold="true" foreground="[0,128,128]">Int_Prod_Vec_coord_nt_v2</Font></Text-field><Text-field style="Text" foreground="[255,102,0]" size="14" layout="Normal"><Font size="12" foreground="[255,102,0]">Ojo: este metodo funciona a partir de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==</Equation><Font size="12" foreground="[255,102,0]">, k  &gt;= 2.</Font></Text-field><Text-field style="Text" foreground="[255,102,0]" size="14" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" foreground="[0,128,128]">Realiza el producto interior por e_ip sobre un vector escrito en coordenadas con respecto a una base
de BT_ini = [list,list]. El resultado es un vector en coordenadas en la base BT_fin = [list,list].
Puesto que sobre listas largas se tiene problemas, esta version convierte el vector de Salida en Array
para evitar el problema. </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L122" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Vec_coord_nt_lin := proc(coord_vect::list, B_ini::list, B_fin::list, e_ip):: list:
   local Res_Coord, i, C1, C2, index_c:
   Res_Coord := convert(Vector(1 .. nops(B_fin), 0), Array):<Font foreground="[255,204,0]">
</Font>   for i from 1 to nops(coord_vect) do:
       if coord_vect[i]&lt;&gt;0 then
          C1:= B_ini[i][1]:
          C2:= B_ini[i][2]:
          if C1[1] = e_ip then 
             index_c:= Find_Element(B_fin,C2):
             if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>                  Res_Coord[index_c]:= Res_Coord[index_c] + coord_vect[i]:
             fi:
          fi:
       fi:
   od:<Font foreground="[255,204,0]">
</Font>   return convert(Res_Coord,list):
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L123" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L45" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Vec_coord_nt := proc(coord_vect::list , BT_ini::list, BT_fin::list, e_ip):: list:
   local Res_Coord, i, C1, C2, P_int, index_c:
   Res_Coord := convert(Vector(1 .. nops(BT_fin), 0), list):<Font foreground="[255,204,0]">
</Font>   for i from 1 to nops(coord_vect) do:
       if coord_vect[i]&lt;&gt;0 then
          <Font foreground="[255,204,0]"># lprint(`analizando coordenada `,i,` en vector de entrada`):</Font>
          C1:= BT_ini[i][1]:
          C2:= BT_ini[i][2]:
          P_int:= Int_Prod_Ebasis(C1,e_ip):
          index_c:= Find_Element(BT_fin,[P_int[1],C2]):
          if index_c &lt;&gt; -1 then
              <Font foreground="[255,204,0]"># lprint(`cambiando coordenada `,index_c,` en vector de salida por `, P_int[2]*coord_vect[i]):
</Font>              Res_Coord[index_c]:= P_int[2]*coord_vect[i]:
          fi:
       fi:
   od:<Font foreground="[255,204,0]">
</Font>   return Res_Coord:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L102" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L92" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Vec_coord_nt_v2 := proc(coord_vect::list , BT_ini::list, BT_fin::list, e_ip):: list:
   local Res_Coord, i, C1, C2, P_int, index_c:
   Res_Coord := convert(Vector(1 .. nops(BT_fin), 0), Array):<Font foreground="[255,204,0]">
</Font>   for i from 1 to nops(coord_vect) do:
       if coord_vect[i]&lt;&gt;0 then
          <Font foreground="[255,204,0]"># lprint(`analizando coordenada `,i,` en vector de entrada`):</Font>
          C1:= BT_ini[i][1]:
          C2:= BT_ini[i][2]:
          P_int:= Int_Prod_Ebasis(C1,e_ip):
          index_c:= Find_Element(BT_fin,[P_int[1],C2]):
          if index_c &lt;&gt; -1 then
              <Font foreground="[255,204,0]"># lprint(`cambiando coordenada `,index_c,` en vector de salida por `, P_int[2]*coord_vect[i]):
</Font>              Res_Coord[index_c]:= P_int[2]*coord_vect[i]:
          fi:
       fi:
   od:<Font foreground="[255,204,0]">
</Font>   return convert(Res_Coord,list):
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1159" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14" encoding="UTF-8">Producto interior de un vector escrito en coordenadas en una base \316\233B de \316\233V</Font></Text-field></Title><Text-field style="Text" underline="true" bold="true" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Int_Prod_Vec_coord_t_lin</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto interior por e_ip sobre un vector escrito en coordenadas con respecto a una base  B1* y devuelve </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">como resultado un numero que es la coordenada e_ip respectivamente.</Font></Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field style="Text" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Int_Prod_Vec_coord_t</Font></Text-field><Text-field style="Text" underline="true" foreground="[255,102,0]" layout="Normal"><Font underline="false" foreground="[255,102,0]">Ojo, este metodo funciona a partir de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==</Equation><Font underline="false" foreground="[255,102,0]">, k &gt;=2.</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" foreground="[0,128,128]">Realiza el producto interior por e_ip sobre un vector escrito en coordenadas con respecto a una base
de BD_ini = [list]. El resultado es un vector en coordenadas en la base BD_fin = [list].</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" underline="true" bold="true" foreground="[0,128,128]">Int_Prod_Vec_coord_t_v2</Font></Text-field><Text-field style="Text" foreground="[255,102,0]" size="14" layout="Normal"><Font size="12" foreground="[255,102,0]">Ojo, este metodo funciona a partir de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2KVEnJiM5MjM7RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lK2ZvcmVncm91bmRHUSxbMjU1LDEwMiwwXUYnLyU2c2VsZWN0aW9uLXBsYWNlaG9sZGVyR0Y0LyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y/LUYjNiotRi82KFEia0YnRjIvRjZGNEY4L0Y+USxib2xkLWl0YWxpY0YnRkBGMkZHRjgvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGSEZALyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJ0YyRjhGSkZMRj1GQA==</Equation><Font size="12" foreground="[255,102,0]">, k &gt;=2.</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"><Font size="12" foreground="[0,128,128]">Realiza el producto interior por e_ip sobre un vector escrito en coordenadas con respecto a una base
de BD_ini = [list]. El resultado es un vector en coordenadas en la base BD_fin = [list].
Puesto que sobre listas largas se tiene problemas, esta version convierte el vector de Salida en Array
para evitar el problema. </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" size="14" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L120" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Vec_coord_t_lin := proc(coord_vect::list , e_ip)
   return coord_vect[e_ip]:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L121" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L57" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Vec_coord_t := proc(coord_vect::list , BD_ini::list, BD_fin::list, e_ip):: list:
   local Res_Coord, i, C1, P_int, index_c:
   Res_Coord := convert(Vector(1 .. nops(BD_fin), 0), list):<Font foreground="[255,204,0]">
</Font>   for i from 1 to nops(coord_vect) do:
       if coord_vect[i]&lt;&gt;0 then
          <Font foreground="[255,204,0]"># lprint(`analizando coordenada `,i,` en vector de entrada`):
</Font>          C1:= BD_ini[i]:
          P_int:= Int_Prod_Ebasis(C1,e_ip):
          index_c:= Find_Element(BD_fin,P_int[1]):
          if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>              Res_Coord[index_c]:= P_int[2]*coord_vect[i]:
          fi:
       fi:
   od:<Font foreground="[255,204,0]">
</Font>   return Res_Coord:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L103" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L98" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Int_Prod_Vec_coord_t_v2 := proc(coord_vect::list , BD_ini::list, BD_fin::list, e_ip):: list:
   local Res_Coord, i, C1, P_int, index_c:
   Res_Coord := convert(Vector(1 .. nops(BD_fin), 0), Array):<Font foreground="[255,204,0]">
</Font>   for i from 1 to nops(coord_vect) do:
       if coord_vect[i]&lt;&gt;0 then
          <Font foreground="[255,204,0]"># lprint(`analizando coordenada `,i,` en vector de entrada`):
</Font>          C1:= BD_ini[i]:
          P_int:= Int_Prod_Ebasis(C1,e_ip):
          index_c:= Find_Element(BD_fin,P_int[1]):
          if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>              Res_Coord[index_c]:= P_int[2]*coord_vect[i]:
          fi:
       fi:
   od:<Font foreground="[255,204,0]">
</Font>   return convert(Res_Coord,list):
end proc:
</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L59" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="BD1 := BaseExt(4)[3];" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzY1LUkjbWlHRiQ2JVEkQkQxRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqJmNvbG9uZXE7RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtRiw2JVEoQmFzZUV4dEYnRi9GMi1JKG1mZW5jZWRHRiQ2JC1GIzYlLUkjbW5HRiQ2JFEiNEYnRjkvJStleGVjdXRhYmxlR0Y9RjlGOS1GUzYmLUYjNiUtRlg2JFEiM0YnRjlGZW5GOUY5LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnLUY2Ni1RIjtGJ0Y5RjsvRj9GMUZARkJGREZGRkgvRktRJjAuMGVtRidGTS1JJ21zcGFjZUdGJDYmLyUnaGVpZ2h0R1EmMC4wZXhGJy8lJndpZHRoR0Zpby8lJmRlcHRoR0ZfcC8lKmxpbmVicmVha0dRKG5ld2xpbmVGJy1GLDYlUSRCRDJGJ0YvRjJGNUZPRlItRlM2Ji1GIzYlLUZYNiRRIjJGJ0Y5RmVuRjlGOUZeb0Zhb0Zkb0Zqby1GLDYlUTBJbnRfUHJvZF9FYmFzaXNGJ0YvRjItRlM2JC1GIzYoRistRlM2JkZVRjlGXm9GYW8tRjY2LVEiLEYnRjlGO0Znb0ZARkJGREZGRkhGaG8vRk5RLDAuMzMzMzMzM2VtRidGXnFGZW5GOUY5RmRvRmVuRjk=">Qyg+SSRCRDFHNiImLUkoQmFzZUV4dEdGJTYjIiIlNiMiIiQiIiI+SSRCRDJHRiUmRic2IyIiI0YtLUkwSW50X1Byb2RfRWJhc2lzR0YlNiQmRiRGKUYyRi0=</Equation></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkQkQxRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2LC1GUDYmLUYjNiotSSNtbkdGJDYkUSIxRidGOS1GNjYtUSIsRidGOUY7L0Y/RjFGQEZCRkRGRkZIRkovRk5RLDAuMzMzMzMzM2VtRictRlk2JFEiMkYnRjlGZm4tRlk2JFEiM0YnRjkvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRmZuLUZQNiYtRiM2KkZYRmZuRlxvRmZuLUZZNiRRIjRGJ0Y5RmJvRmVvRjlGOUZnb0Zqb0Zmbi1GUDYmLUYjNipGWEZmbkZfb0ZmbkZhcEZib0Zlb0Y5RjlGZ29Gam9GZm4tRlA2Ji1GIzYqRlxvRmZuRl9vRmZuRmFwRmJvRmVvRjlGOUZnb0Zqb0Zib0Zlb0Y5RjlGZ29Gam9GYm9GZW9GOQ==">NyY3JSIiIiIiIyIiJDclRiRGJSIiJTclRiRGJkYoNyVGJUYmRig=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkQkQyRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2MC1GUDYmLUYjNigtSSNtbkdGJDYkUSIxRidGOS1GNjYtUSIsRidGOUY7L0Y/RjFGQEZCRkRGRkZIRkovRk5RLDAuMzMzMzMzM2VtRictRlk2JFEiMkYnRjkvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRmZuLUZQNiYtRiM2KEZYRmZuLUZZNiRRIjNGJ0Y5Rl9vRmJvRjlGOUZkb0Znb0Zmbi1GUDYmLUYjNihGWEZmbi1GWTYkUSI0RidGOUZfb0Zib0Y5RjlGZG9GZ29GZm4tRlA2Ji1GIzYoRlxvRmZuRl5wRl9vRmJvRjlGOUZkb0Znb0Zmbi1GUDYmLUYjNihGXG9GZm5GZXBGX29GYm9GOUY5RmRvRmdvRmZuLUZQNiYtRiM2KEZecEZmbkZlcEZfb0Zib0Y5RjlGZG9GZ29GX29GYm9GOUY5RmRvRmdvRl9vRmJvRjk=">Nyg3JCIiIiIiIzckRiQiIiQ3JEYkIiIlNyRGJUYnNyRGJUYpNyRGJ0Yp</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1JI21uR0YkNiRRIjNGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictSSNtb0dGJDYtUSIsRidGNi8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0Y/LyUqc3ltbWV0cmljR0Y/LyUobGFyZ2VvcEdGPy8lLm1vdmFibGVsaW1pdHNHRj8vJSdhY2NlbnRHRj8vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GMzYkUSI0RidGNi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGP0Y2RjYvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGOS1GMzYkUSIxRidGNkZWRllGNkY2RmVuRmhu">NyQ3JCIiJCIiJSIiIg==</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L116" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="Int_Prod_Ebasis(BD1[4], 1);" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYtLUkjbWlHRiQ2JVEwSW50X1Byb2RfRWJhc2lzRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkobWZlbmNlZEdGJDYkLUYjNictRiw2JVEkQkQxRidGL0YyLUY2NiYtRiM2JC1JI21uR0YkNiRRIjRGJy9GM1Enbm9ybWFsRidGRUZFLyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnLUkjbW9HRiQ2LVEiLEYnRkUvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjEvJSlzdHJldGNoeUdGUy8lKnN5bW1ldHJpY0dGUy8lKGxhcmdlb3BHRlMvJS5tb3ZhYmxlbGltaXRzR0ZTLyUnYWNjZW50R0ZTLyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictRkI2JFEiMUYnRkVGRUZFLUZONi1RIjtGJ0ZFRlFGVEZWRlhGWkZmbkZobkZqbi9GXm9RLDAuMjc3Nzc3OGVtRictSSdtc3BhY2VHRiQ2Ji8lJ2hlaWdodEdRJjAuMGV4RicvJSZ3aWR0aEdGXG8vJSZkZXB0aEdGXXAvJSpsaW5lYnJlYWtHUShuZXdsaW5lRictRmlvNiZGW3BGXnBGYHAvRmNwUSVhdXRvRidGKy1GNjYkLUYjNidGOkY9Rk0tRkI2JFEiM0YnRkVGRUZFRmNvLUZONi1RIUYnRkVGUS9GVUZTRlZGWEZaRmZuRmhuL0Zbb0Znb0Zmby8lK2V4ZWN1dGFibGVHRlNGRQ==">QyYtSTBJbnRfUHJvZF9FYmFzaXNHNiI2JCZJJEJEMUdGJTYjIiIlIiIiRistRiQ2JEYnIiIkRis=</Equation></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2Ji1JI21vR0YkNi1RIUYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGOy8lKXN0cmV0Y2h5R0Y7LyUqc3ltbWV0cmljR0Y7LyUobGFyZ2VvcEdGOy8lLm1vdmFibGVsaW1pdHNHRjsvJSdhY2NlbnRHRjsvJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZKLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y7RjZGNi8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1GMzYtUSIsRidGNkY5L0Y9USV0cnVlRidGPkZARkJGREZGL0ZJUSYwLjBlbUYnL0ZMUSwwLjMzMzMzMzNlbUYnLUkjbW5HRiQ2JFEiMUYnRjZGTUZQRjZGNkZSRlU=">NyQ3IiIiIg==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1JI21uR0YkNiRRIjJGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictSSNtb0dGJDYtUSIsRidGNi8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0Y/LyUqc3ltbWV0cmljR0Y/LyUobGFyZ2VvcEdGPy8lLm1vdmFibGVsaW1pdHNHRj8vJSdhY2NlbnRHRj8vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GMzYkUSI0RidGNi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGP0Y2RjYvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGOS1GLDYlLUY6Ni1RKiZ1bWludXMwO0YnRjZGPS9GQUY/RkNGRUZHRklGSy9GTlEsMC4yMjIyMjIyZW1GJy9GUUZiby1GMzYkUSIxRidGNkY2RlZGWUY2RjZGZW5GaG4=">NyQ3JCIiIyIiJSEiIg==</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L60" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="Coordenadas_ini := [3, 8, 5, 0];" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzY3LUkjbWlHRiQ2JVEwQ29vcmRlbmFkYXNfaW5pRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqJmNvbG9uZXE7RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2Ki1JI21uR0YkNiRRIjNGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkgvRktRJjAuMGVtRicvRk5RLDAuMzMzMzMzM2VtRictRlU2JFEiOEYnRjlGWC1GVTYkUSI1RidGOUZYLUZVNiRRIjBGJ0Y5RjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1GNjYtUSI7RidGOUY7RmVuRkBGQkZERkZGSEZmbkZNLUknbXNwYWNlR0YkNiYvJSdoZWlnaHRHUSYwLjBleEYnLyUmd2lkdGhHRmduLyUmZGVwdGhHRmFwLyUqbGluZWJyZWFrR1EobmV3bGluZUYnLUZdcDYmRl9wRmJwRmRwL0ZncFElYXV0b0YnLUYsNiVRI05DRidGL0YyRjUtRiw2JVE1SW50X1Byb2RfVmVjX2Nvb3JkX3RGJ0YvRjItRlA2JC1GIzYrRitGWC1GLDYlUSRCRDFGJ0YvRjJGWC1GLDYlUSRCRDJGJ0YvRjJGWEZULyUrZXhlY3V0YWJsZUdGPUY5RjlGaW9GXHBGaXAtRiw2JVE5SW50X1Byb2RfVmVjX2Nvb3JkX3RfbGluRidGL0YyLUZQNiQtRiM2J0YrRlgtRjY2LVEifkYnRjlGO0Y+RkBGQkZERkZGSEZmbi9GTkZnbi1GVTYkUSIxRidGOUY5RjlGaW9GXHBGaXAtRjY2LVEhRidGOUY7Rj5GQEZCRkRGRkZIRkpGTUZdckY5">Qyg+STBDb29yZGVuYWRhc19pbmlHNiI3JiIiJCIiKSIiJiIiISIiIj5JI05DR0YlLUk1SW50X1Byb2RfVmVjX2Nvb3JkX3RHRiU2JkYkSSRCRDFHRiVJJEJEMkdGJUYnRistSTlJbnRfUHJvZF9WZWNfY29vcmRfdF9saW5HRiU2JEYkRitGKw==</Equation></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEwQ29vcmRlbmFkYXNfaW5pRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2LC1JI21uR0YkNiRRIjNGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkhGSi9GTlEsMC4zMzMzMzMzZW1GJy1GVTYkUSI4RidGOUZYLUZVNiRRIjVGJ0Y5RlgtRlU2JFEiMEYnRjkvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRmFvRmRvRjk=">NyYiIiQiIikiIiYiIiE=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEjTkNGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSp+JiM4Nzg4O35GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGTC1JKG1mZW5jZWRHRiQ2Ji1GIzYwLUkjbW5HRiQ2JFEiM0YnRjktRjY2LVEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSEZKL0ZOUSwwLjMzMzMzMzNlbUYnLUZVNiRRIjBGJ0Y5RlgtRiM2JS1GNjYtUSomdW1pbnVzMDtGJ0Y5RjtGPkZARkJGREZGRkgvRktRLDAuMjIyMjIyMmVtRicvRk5GYW8tRlU2JFEiNUYnRjlGOUZYRmhuRlhGaG5GWEZobi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGZm9GaW9GOQ==">NygiIiQiIiEhIiZGJEYkRiQ=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkjbW5HNiMvSSttb2R1bGVuYW1lRzYiSSxUeXBlc2V0dGluZ0dJKF9zeXNsaWJHRic2JFEiM0YnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJw==">IiIk</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L62" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="BaseFormal := [x1x2, x1x3, x1x4, x2x3, x2x4, x3x4]:" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYwLUkjbWlHRiQ2JVErQmFzZUZvcm1hbEYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKiZjb2xvbmVxO0YnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLUkobWZlbmNlZEdGJDYmLUYjNi8tRiw2JVEleDF4MkYnRi9GMi1GNjYtUSIsRidGOUY7L0Y/RjFGQEZCRkRGRkZIL0ZLUSYwLjBlbUYnL0ZOUSwwLjMzMzMzMzNlbUYnLUYsNiVRJXgxeDNGJ0YvRjJGVy1GLDYlUSV4MXg0RidGL0YyRlctRiw2JVEleDJ4M0YnRi9GMkZXLUYsNiVRJXgyeDRGJ0YvRjJGVy1GLDYlUSV4M3g0RidGL0YyLyUrZXhlY3V0YWJsZUdGPUY5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRictRjY2LVEiOkYnRjlGO0Y+RkBGQkZERkZGSEZKRk0tSSdtc3BhY2VHRiQ2Ji8lJ2hlaWdodEdRJjAuMGV4RicvJSZ3aWR0aEdGZm4vJSZkZXB0aEdGaHAvJSpsaW5lYnJlYWtHUShuZXdsaW5lRictRiw2JVEwVmVjdG9yZXNfRm9ybWFsRidGL0YyLUZQNiQtRiM2Jy1GUDYmLUYjNiUtRiw2JVEjTkNGJ0YvRjJGaG9GOUY5RmpvRl1wRldGK0Zob0Y5RjktRjY2LVEiO0YnRjlGO0ZaRkBGQkZERkZGSEZlbkZNLUY2Ni1RIn5GJ0Y5RjtGPkZARkJGREZGRkhGZW4vRk5GZm5GY3AtRmRwNiZGZnBGaXBGW3EvRl5xUSVhdXRvRictRjY2LVEhRidGOUY7Rj5GQEZCRkRGRkZIRkpGTUZob0Y5">QyY+SStCYXNlRm9ybWFsRzYiNyhJJXgxeDJHRiVJJXgxeDNHRiVJJXgxeDRHRiVJJXgyeDNHRiVJJXgyeDRHRiVJJXgzeDRHRiUhIiItSTBWZWN0b3Jlc19Gb3JtYWxHRiU2JDcjSSNOQ0dGJUYkIiIi</Equation></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYmLUYsNiYtRiw2Ji1JI21uR0YkNiRRIjNGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictSSNtb0dGJDYtUTEmSW52aXNpYmxlVGltZXM7RidGNi8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPy8lKXN0cmV0Y2h5R0Y/LyUqc3ltbWV0cmljR0Y/LyUobGFyZ2VvcEdGPy8lLm1vdmFibGVsaW1pdHNHRj8vJSdhY2NlbnRHRj8vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0ZOLUkjbWlHRiQ2JVEleDF4MkYnLyUnaXRhbGljR1EldHJ1ZUYnL0Y3USdpdGFsaWNGJ0Y2LUY6Ni1RKCZtaW51cztGJ0Y2Rj1GQEZCRkRGRkZIRkovRk1RLDAuMjIyMjIyMmVtRicvRlBGaG4tRiw2Ji1GMzYkUSI1RidGNkY5LUZSNiVRJXgxeDRGJ0ZVRlhGNkY2LyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y/RjZGNi8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJw==">NyMsJkkleDF4Mkc2IiIiJEkleDF4NEc2IiEiJg==</Equation></Text-field>
</Output>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" size="14" layout="Heading 1"><Font size="14">Combinacion lineal de representantes de </Font><Equation executable="false" style="Heading 1" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEiSEYnLyUlc2l6ZUdRIzE0RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRicvJSxtYXRodmFyaWFudEdRJWJvbGRGJy8lK2ZvbnR3ZWlnaHRHRj0tRiM2KS1GLzYoUSJwRidGMkY1RjhGO0Y+LUkjbW9HRiQ2MFEiLEYnRjJGOEY7Rj4vJSZmZW5jZUdGNy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0Y3LyUqc3ltbWV0cmljR0Y3LyUobGFyZ2VvcEdGNy8lLm1vdmFibGVsaW1pdHNHRjcvJSdhY2NlbnRHRjcvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GLzYoUSJxRidGMkY1RjhGO0Y+RjJGOEY7Rj4vJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUZGNi1RIUYnL0Y8USdub3JtYWxGJ0ZJL0ZMRjdGTkZQRlJGVEZWL0ZZUSwwLjI3Nzc3NzhlbUYnL0ZmbkZlb0YyRjhGO0Y+">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEiSEYnLyUlc2l6ZUdRIzE0RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRicvJSxtYXRodmFyaWFudEdRJWJvbGRGJy8lK2ZvbnR3ZWlnaHRHRj0tRiM2KS1GLzYoUSJwRidGMkY1RjhGO0Y+LUkjbW9HRiQ2MFEiLEYnRjJGOEY7Rj4vJSZmZW5jZUdGNy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0Y3LyUqc3ltbWV0cmljR0Y3LyUobGFyZ2VvcEdGNy8lLm1vdmFibGVsaW1pdHNHRjcvJSdhY2NlbnRHRjcvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GLzYoUSJxRidGMkY1RjhGO0Y+RjJGOEY7Rj4vJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUZGNi1RIUYnL0Y8USdub3JtYWxGJ0ZJL0ZMRjdGTkZQRlJGVEZWL0ZZUSwwLjI3Nzc3NzhlbUYnL0ZmbkZlb0YyRjhGO0Y+</Equation></Text-field></Title><Text-field style="Text" opaque="true" bold="true" foreground="[0,128,128]" background="[255,255,199]" layout="Normal"><Font opaque="true" background="[255,255,199]" bold="true" foreground="[0,128,128]">Nota: Una vez aplicada la accion central sobre cada representante de clase de cohomologia, es necesario identificar con </Font></Text-field><Text-field style="Text" opaque="true" bold="true" foreground="[0,128,128]" background="[255,255,199]" layout="Normal"><Font opaque="true" background="[255,255,199]" bold="true" foreground="[0,128,128]">cuales representantes de grado cohomologico menor se corresponde tal resultado.</Font></Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" underline="true" bold="true" foreground="[128,0,128]">id_Rep_Kernel</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" foreground="[0,128,128]">Devuelve una lista de lista, cuya i-esima lista representa las coordenadas de List_Vec[i] con respecto a una base Basis_Ker.</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" underline="true" bold="true" foreground="[0,128,128]">Input:</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" foreground="[0,128,128]">List_Vec   = lista de vectores en Hpq</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" foreground="[0,128,128]">Basis_Ker = base de los cociclos en Cpq escogida. Es mejor elegir la base de cociclos formada por los representantes de</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" foreground="[0,128,128]">                    cohomologia junto con la base de los cobordes.</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,51,102]" background="[255,255,199]" layout="Normal"><Font opaque="true" background="[255,255,199]" foreground="[0,51,102]">Una vez invocado <Font bold="true">id_Rep_Kernel</Font> y teniendo la lista de las coordenadas en la misma base de cociclo usada sobre <Font bold="true">id_Rep_Kernel</Font>, </Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,51,102]" background="[255,255,199]" layout="Normal"><Font opaque="true" background="[255,255,199]" foreground="[0,51,102]">vemos a cual representante de cohomologia pertenece cada elemento respectivamente. </Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" underline="true" bold="true" foreground="[128,0,128]">id_Rep_Coh</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" underline="true" bold="true" foreground="[0,128,128]">Input:</Font><Font opaque="false" foreground="[0,128,128]">
List_Coord = Lista de coordenadas con respecto a la base de cociclos Basis_C.
B_Coc        = Base de Cociclos
B_Cob        = Base de Cobordes</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" underline="true" bold="true" foreground="[128,0,128]">id_Rep_Coh_v2</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="true" underline="true" bold="true" foreground="[0,128,128]">Input:</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" foreground="[0,128,128]">List_Coord = Lista de coordenadas con respecto a la base de cociclos Basis_CoH_B formada por  <Font bold="true">[c1,.....,ck,w1,.....,wl]</Font> </Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" foreground="[0,128,128]">                      donde <Font bold="true">[c1,.....,ck]</Font> es la base de la cohomologia y <Font bold="true">[w1,.....,wl]</Font> es la base de los cobordes.
B_CoH_B    = Base de Cociclos formada por la cohomologia y los cobordes.
B_Cob        = Base de Cobordes</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" bold="true" foreground="[0,128,128]">Nota:</Font><Font opaque="false" foreground="[0,128,128]"> En este caso es necesario invocar id_Rep_Kernel con la base de cociclos formada por <Font bold="true">[c1,.....,ck,w1,.....,wl]</Font></Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" underline="true" bold="true" foreground="[128,0,128]">Mostrar_Representantes</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"><Font opaque="false" foreground="[0,128,128]" encoding="UTF-8">Muestra en pantalla el resultado de id_Rep_Coh_v2 por cada representante de cohomolog\303\255a evaluado por la accion central.</Font></Text-field><Text-field style="Text" opaque="true" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L2128" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">id_Rep_Kernel := proc(List_Vec::list , Basis_Ker::list)::list:

    local List_Coordenates, i, j, v_aux:
    List_Coordenates:=[]:
    for i from 1 to nops(List_Vec) do:
        v_aux:=Coord(List_Vec[i], Basis_Ker): <Font foreground="[51,204,204]"># escribo List_Vec[i] en termino de la base de cociclos
</Font>        List_Coordenates:= [op(List_Coordenates),v_aux]:
    od:
    return List_Coordenates:

end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2130" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">id_Rep_Coh := proc(List_Coord::list , B_Coc::list, B_Cob::list)::list:<Font foreground="[255,102,0]">

   </Font><Font foreground="[128,0,0]">local Coc, Cob:</Font><Font foreground="[255,102,0]">
</Font>   local List_Repr,Repr_List, sublist_cic, i, j, v_aux:
   Coc := Convert_Vector(B_Coc):
   Cob := Convert_Vector(B_Cob):
   List_Repr:=[]:
   for i from 1 to nops(List_Coord) do:
       sublist_cic:=[]:
       for j from 1 to nops(List_Coord[i]) do:
           if List_Coord[i][j]&lt;&gt;0 then
                <Font foreground="[0,128,128]">sublist_cic:=[op(sublist_cic),List_Coord[i][j]*Coc[j]]:
</Font>           fi:
       od:
       Repr_List := Cociente_corr(sublist_cic,Cob):
       List_Repr:= [op(List_Repr),Repr_List]:
   od:
   return List_Repr:

end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2132" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">id_Rep_Coh_v2 := proc(List_Coord::list , B_CoH_Cob::list, B_Cob::list)::list:<Font foreground="[255,102,0]">

   </Font><Font foreground="[128,0,0]">local CoH_Cob, Cob:
</Font>   local List_Repr, Repr_List, sublist_cic, i, j, f_index, v_aux:
   CoH_Cob := Convert_Vector(B_CoH_Cob):
   Cob := Convert_Vector(B_Cob):
   <Font foreground="[0,128,128]">f_index:=nops(B_CoH_Cob)-nops(B_Cob):</Font>
   List_Repr:=[]:
   for i from 1 to nops(List_Coord) do:
       sublist_cic:=[]:
       for j from 1 to f_index do:
           if List_Coord[i][j]&lt;&gt;0 then
                <Font foreground="[0,128,128]">sublist_cic:=[op(sublist_cic),List_Coord[i][j]*CoH_Cob[j]]:
</Font>           fi:
       od:<Font foreground="[255,204,153]">
       </Font>List_Repr := [op(List_Repr),Convert_list(sublist_cic)]:
   od:
   return List_Repr:

end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2134" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]" encoding="UTF-8"># Este metodo une las rutinas anteriores para devolver directamente la identificaci\303\263n de los 
</Font><Font foreground="[255,153,0]"># Representantes de clase de cohomologia</Font>

Identificar_Representantes := proc(eval_central, B_coh, B_cob, opt)
   local Coh_Cob, Salida, Central_Coh:

   Coh_Cob := Merge_2_list_list(B_coh, B_cob):
   Central_Coh := id_Rep_Kernel(eval_central, Coh_Cob):
   if opt = 1 then:
      Salida := id_Rep_Coh(Central_Coh, Coh_Cob, B_cob):
   elif opt = 2 then:
      Salida := id_Rep_Coh_v2(Central_Coh, Coh_Cob, B_cob):
   else:
      Salida := id_Rep_Coh(Central_Coh, Coh_Cob, B_cob):
   fi:

return Salida:
end proc:
</Text-field>
</Input>
</Group>
<Group labelreference="L3516" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Mostrar_Representantes := proc(List_Vec::list , List_Rep::list, Base_sal::list, Base_lleg::list)

    local i, sal_aux:
    sal_aux:=Vectores_Formal(List_Vec,Base_sal):
    
    for i from 1 to nops(List_Vec) do:
        print(sal_aux[i],` ---&gt; `,Vectores_Formal(List_Rep[i],Base_lleg)):
        print(`     ..     `):             
    od:

end proc:
</Text-field>
</Input>
</Group>
</Section>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Rutinas para Producto copa</Text-field></Title><Text-field style="Text" layout="Normal">Los siguientes metodos son implementados para calcular el producto copa de los representantes de cohomologia Hpq</Text-field>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Wedge Ordenado de dos elementos bases</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto wedge entre dos elementos bases vec1, vec2</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Input</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">vec1 = [v1,...,vk] con v1&lt;...&lt;vk</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">vec2 = [w1,...,wl] con w1&lt;....&lt;wl</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Output</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]" encoding="UTF-8">vec1\342\210\247vec2 que es cero o un elemento base de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EpJkxhbWJkYTtGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lNnNlbGVjdGlvbi1wbGFjZWhvbGRlckdRJXRydWVGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2KS1GLzYmUSJrRicvRjNGOkY1L0Y8USdpdGFsaWNGJy1JI21vR0YkNi5RIitGJ0Y1RjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSwwLjIyMjIyMjJlbUYnLyUncnNwYWNlR0ZaLUYvNiZRImxGJ0ZDRjVGREY1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYmUSJWRidGQ0Y1RkRGNUZqbkZcb0Y7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EpJkxhbWJkYTtGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lNnNlbGVjdGlvbi1wbGFjZWhvbGRlckdRJXRydWVGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2KS1GLzYmUSJrRicvRjNGOkY1L0Y8USdpdGFsaWNGJy1JI21vR0YkNi5RIitGJ0Y1RjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSwwLjIyMjIyMjJlbUYnLyUncnNwYWNlR0ZaLUYvNiZRImxGJ0ZDRjVGREY1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYmUSJWRidGQ0Y1RkRGNUZqbkZcb0Y7</Equation></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">recordar que esa es la estructura interna que representa elementos bases sobre </Font><Equation executable="false" style="Text" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNiYtRi82JlEia0YnL0YzRjpGNS9GPFEnaXRhbGljRidGQ0Y1RkQvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNiZRIlZGJ0ZDRjVGRC1JI21vR0YkNi5RIn5GJ0Y1RjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0Zqbi1GLzYmUSJ5RidGQ0Y1RkRGTC1GLDYlLUYvNilRKSZMYW1iZGE7RidGMkY1LyUrZXhlY3V0YWJsZUdGOkY4LyUwZm9udF9zdHlsZV9uYW1lR1EoMkR+TWF0aEYnRjstRiM2JS1GLzYoUSJsRidGQ0Y1RmVvRmdvRkRGNUY7RkYtRi82KEZLRkNGNUZlb0Znb0ZELUZNNjBGT0Y1RmVvRmdvRjtGUEZSRlRGVkZYRlpGZm5GaG5GW28tRi82KFEwcmVzcGVjdGl2YW1lbnRlRidGQ0Y1RmVvRmdvRkQtRk02MFEiLkYnRjVGZW9GZ29GO0ZQRlJGVEZWRlhGWkZmbkZobkZbb0ZhcEY1Rjs=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYvLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNiYtRi82JlEia0YnL0YzRjpGNS9GPFEnaXRhbGljRidGQ0Y1RkQvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNiZRIlZGJ0ZDRjVGRC1JI21vR0YkNi5RIn5GJ0Y1RjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0Zqbi1GLzYmUSJ5RidGQ0Y1RkRGTC1GLDYlLUYvNilRKSZMYW1iZGE7RidGMkY1LyUrZXhlY3V0YWJsZUdGOkY4LyUwZm9udF9zdHlsZV9uYW1lR1EoMkR+TWF0aEYnRjstRiM2JS1GLzYoUSJsRidGQ0Y1RmVvRmdvRkRGNUY7RkYtRi82KEZLRkNGNUZlb0Znb0ZELUZNNjBGT0Y1RmVvRmdvRjtGUEZSRlRGVkZYRlpGZm5GaG5GW28tRi82KFEwcmVzcGVjdGl2YW1lbnRlRidGQ0Y1RmVvRmdvRkQtRk02MFEiLkYnRjVGZW9GZ29GO0ZQRlJGVEZWRlhGWkZmbkZobkZbb0ZhcEY1Rjs=</Equation></Text-field>
<Group hide-output="false" labelreference="L113" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">sort_wedge := proc(vec1::list , vec2::list) :: list:
    local sign, aux_list, S, aux_e, i, j,Res_List:
    sign := 0:
    Res_List:=[];
    aux_list:=[];
    <Font foreground="[0,128,128]"># chequeo que vec1 y vec2 no tienen elementos en comunes (caso contrario el wedge es cero)
</Font>    S := convert(vec1, set) intersect convert(vec2, set):
    if nops(S) = 0 then  
       aux_list := Merge_2_list(vec1, vec2): 
       for i from 1 to nops(aux_list)-1 do:
           for j from i+1 to nops(aux_list) do:
               if aux_list[i] &gt; aux_list[j] then
                  aux_e := aux_list[i]:
                  aux_list[i] := aux_list[j]:
                  aux_list[j] := aux_e:
                  sign := sign+1:
               fi:
           od:
       od:
       sign := (-1)^(sign mod 2):
    fi:
    Res_List := [op(Res_List),aux_list,sign]:
    return Res_List:
end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2123" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" bold="false" layout="Normal"><Font foreground="[255,0,0]" bold="false"># No borrar estos ejemplos</Font><Font bold="false">
<Font foreground="[51,153,102]">sort_wedge([2], []); 
sort_wedge([2], [1]); 
sort_wedge([1], [2])</Font></Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2Ji1JI21uR0YkNiRRIjJGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRicvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHUSZmYWxzZUYnRjZGNi8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1JI21vR0YkNi1RIixGJ0Y2LyUmZmVuY2VHRj4vJSpzZXBhcmF0b3JHUSV0cnVlRicvJSlzdHJldGNoeUdGPi8lKnN5bW1ldHJpY0dGPi8lKGxhcmdlb3BHRj4vJS5tb3ZhYmxlbGltaXRzR0Y+LyUnYWNjZW50R0Y+LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictRjM2JFEiMUYnRjZGOUY8RjZGNkY/RkI=">NyQ3IyIiIyIiIg==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1JI21uR0YkNiRRIjFGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictSSNtb0dGJDYtUSIsRidGNi8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0Y/LyUqc3ltbWV0cmljR0Y/LyUobGFyZ2VvcEdGPy8lLm1vdmFibGVsaW1pdHNHRj8vJSdhY2NlbnRHRj8vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GMzYkUSIyRidGNi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGP0Y2RjYvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGOS1GLDYlLUY6Ni1RKiZ1bWludXMwO0YnRjZGPS9GQUY/RkNGRUZHRklGSy9GTlEsMC4yMjIyMjIyZW1GJy9GUUZib0YyRjZGVkZZRjZGNkZlbkZobg==">NyQ3JCIiIiIiIyEiIg==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1JI21uR0YkNiRRIjFGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictSSNtb0dGJDYtUSIsRidGNi8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0Y/LyUqc3ltbWV0cmljR0Y/LyUobGFyZ2VvcEdGPy8lLm1vdmFibGVsaW1pdHNHRj8vJSdhY2NlbnRHRj8vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GMzYkUSIyRidGNi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGP0Y2RjYvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGOUYyRlZGWUY2RjZGZW5GaG4=">NyQ3JCIiIiIiI0Yk</Equation></Text-field>
</Output>
</Group>
<Group hide-output="false" labelreference="L2221" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Wedge de dos elementos &quot;formas&quot; sobre </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUkjbWlHRiQ2KVEoJiM5MjM7VkYnLyUlc2l6ZUdRIzE0RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lNnNlbGVjdGlvbi1wbGFjZWhvbGRlckdGNC8lLG1hdGh2YXJpYW50R1ElYm9sZEYnLyUrZm9udHdlaWdodEdGPEYvRjIvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGOkY9">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUkjbWlHRiQ2KVEoJiM5MjM7VkYnLyUlc2l6ZUdRIzE0RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lNnNlbGVjdGlvbi1wbGFjZWhvbGRlckdGNC8lLG1hdGh2YXJpYW50R1ElYm9sZEYnLyUrZm9udHdlaWdodEdGPEYvRjIvJStleGVjdXRhYmxlR0Y3LyUwZm9udF9zdHlsZV9uYW1lR1EqSGVhZGluZ34yRidGOkY9</Equation></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto wedge entre dos elementos Form1, Form2</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Input</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Form1 = [x1,...,xp] donde Form1 = x1*F1 + .... + xp*Fp y cada Fi es un elemento base de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazFGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJWRidGMkY1RjhGO0Y1RkNGRUY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazFGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJWRidGMkY1RjhGO0Y1RkNGRUY7</Equation></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Form2 = [y1,...,yq] donde Form2 = y1*G1 + .... + yq*Gq y cada Gj es un elemento base de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazJGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYmUSJWRicvRjNGOkY1L0Y8USdpdGFsaWNGJy1JI21vR0YkNi1RIUYnRjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0Zfb0Y1RkNGRUY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazJGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYmUSJWRicvRjNGOkY1L0Y8USdpdGFsaWNGJy1JI21vR0YkNi1RIUYnRjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0Zfb0Y1RkNGRUY7</Equation></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">k1,k1 = valores de los wedge de </Font><Font foreground="[0,0,0]"> </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYrLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazFGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYmUSJWRidGMkY1RjstSSNtb0dGJDYuUSJ+RidGNUY7LyUmZmVuY2VHRjQvJSpzZXBhcmF0b3JHRjQvJSlzdHJldGNoeUdGNC8lKnN5bW1ldHJpY0dGNC8lKGxhcmdlb3BHRjQvJS5tb3ZhYmxlbGltaXRzR0Y0LyUnYWNjZW50R0Y0LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGXG8tRi82JlEieUYnRjJGNUY7Rk5GNUZDRkVGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYrLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazFGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYmUSJWRidGMkY1RjstSSNtb0dGJDYuUSJ+RidGNUY7LyUmZmVuY2VHRjQvJSpzZXBhcmF0b3JHRjQvJSlzdHJldGNoeUdGNC8lKnN5bW1ldHJpY0dGNC8lKGxhcmdlb3BHRjQvJS5tb3ZhYmxlbGltaXRzR0Y0LyUnYWNjZW50R0Y0LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGXG8tRi82JlEieUYnRjJGNUY7Rk5GNUZDRkVGOw==</Equation><Font foreground="[0,0,0]"> </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazJGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJWRidGMkY1RjhGO0Y1RkNGRUY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNictRi82JlEjazJGJ0YyRjVGO0Y1LyUrZXhlY3V0YWJsZUdGNC8lMGZvbnRfc3R5bGVfbmFtZUdRJVRleHRGJ0Y7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJWRidGMkY1RjhGO0Y1RkNGRUY7</Equation></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">dimV = dimension del espacio V subyacente de los wedge</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Output</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]" encoding="UTF-8">Coordenadas del wedge  Form1\342\210\247Form2 en </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNiktRi82JlEjazFGJ0YyRjVGOy1JI21vR0YkNi5RIitGJ0Y1RjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSwwLjIyMjIyMjJlbUYnLyUncnNwYWNlR0ZXLUYvNiZRI2syRidGMkY1RjtGNS8lK2V4ZWN1dGFibGVHRjQvJTBmb250X3N0eWxlX25hbWVHUSVUZXh0RidGOy8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRictRi82J1EiVkYnRjJGNUY4RjtGNUZnbkZpbkY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EnJiM5MjM7RicvJSdpdGFsaWNHUSZmYWxzZUYnLyUrZm9yZWdyb3VuZEdRLFswLDEyOCwxMjhdRicvJTZzZWxlY3Rpb24tcGxhY2Vob2xkZXJHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUYjNiktRi82JlEjazFGJ0YyRjVGOy1JI21vR0YkNi5RIitGJ0Y1RjsvJSZmZW5jZUdGNC8lKnNlcGFyYXRvckdGNC8lKXN0cmV0Y2h5R0Y0LyUqc3ltbWV0cmljR0Y0LyUobGFyZ2VvcEdGNC8lLm1vdmFibGVsaW1pdHNHRjQvJSdhY2NlbnRHRjQvJSdsc3BhY2VHUSwwLjIyMjIyMjJlbUYnLyUncnNwYWNlR0ZXLUYvNiZRI2syRidGMkY1RjtGNS8lK2V4ZWN1dGFibGVHRjQvJTBmb250X3N0eWxlX25hbWVHUSVUZXh0RidGOy8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRictRi82J1EiVkYnRjJGNUY4RjtGNUZnbkZpbkY7</Equation></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]" encoding="UTF-8">Se usar\303\241 el metodo anterior para calcular el wedge sobre cada elemento base en el ciclo.</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Nota:</Font><Font foreground="[0,128,128]" encoding="UTF-8"> En este metodo se supone que existe compatibilidad de dimensiones. Es decir, k1+k2 \342\211\244 dim(V). </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Por lo tanto, el chequeo de esta compatibilidad debe realizarse donde se invoca el metodo. Todo el algoritmo</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">respeta la estructura de Base Exterior otorgada por BaseExt(). </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,0]" layout="Normal"><Font bold="true" foreground="[0,128,0]">form_wedge_BE:</Font><Font foreground="[0,128,0]"> Se pasa como parametros k1,k2, dimV y la base exterior (menos uso de memoria)

<Font bold="true">form_wedge_BD:</Font> Se pasa como parametros BD_1 de Form1, BD_2 de Form2 y dimV  (k1,k2, BE son construidos) </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L1157" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">form_wedge_BE := proc(BE, Form1::list ,Form2::list, k1, k2, dimV) :: list:
<Font foreground="[255,102,0]"># Aqui se pasa como parametro la base exterior completa BE</Font>
   local i, j, w_res, e_b1, e_b2, index_c, w_aux, dim_lleg, B_lleg:
   local B_F1, B_F2:

   B_F1:= BE[k1]: <Font foreground="[0,128,128]"># base de la forma 1</Font>
   B_F2:= BE[k2]: <Font foreground="[0,128,128]"># base de la forma 2
</Font>
   dim_lleg := binomial(dimV,k1+k2):
   B_lleg := BE[k1+k2]:

   w_res := convert(Vector(1 .. (dim_lleg), 0), Array): <Font foreground="[255,102,0]"># Coordenadas del wedge resultante.
</Font>
   for i from 1 to nops(Form1) do:
      for j from 1 to nops(Form2) do:
         if Form1[i]&lt;&gt;0 and Form2[j]&lt;&gt;0 then:
            e_b1 := B_F1[i]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de Form1</Font>
            e_b2 := B_F2[j]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de Form2</Font>
            w_aux := sort_wedge(e_b1,e_b2):
            index_c:= Find_Element(B_lleg,w_aux[1]):
            if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>                w_res[index_c]:= w_res[index_c] + w_aux[2]*Form1[i]*Form2[j]:
            fi:
         fi: 
      od:
   od:
   return convert(w_res,list):
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1174" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=</Equation></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1175" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">form_wedge_BD := proc(Form1::list, BD_1::list, Form2::list, BD_2::list, dimV) :: list:
   local i, j, k1, k2:
   local w_res, e_b1, e_b2, index_c, w_aux, dim_lleg, B_lleg:
   local B_F1, B_F2, BE:

   k1:= nops(BD_1[1]): # identifico wedge de Form1
   k2:= nops(BD_2[1]): # identifico wedge de Form2

   BE:= BaseExt(dimV):

   B_F1:= BE[k1]: <Font foreground="[0,128,128]"># base de la forma 1</Font>
   B_F2:= BE[k2]: <Font foreground="[0,128,128]"># base de la forma 2
</Font>
   dim_lleg := binomial(dimV,k1+k2):
   B_lleg := BE[k1+k2]:

   w_res := convert(Vector(1 .. (dim_lleg), 0), Array): <Font foreground="[255,102,0]"># Coordenadas del wedge resultante.
</Font>
   for i from 1 to nops(Form1) do:
      for j from 1 to nops(Form2) do:
         if Form1[i]&lt;&gt;0 and Form2[j]&lt;&gt;0 then:
            e_b1 := B_F1[i]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de Form1</Font>
            e_b2 := B_F2[j]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de Form2</Font>
            w_aux := sort_wedge(e_b1,e_b2):
            index_c:= Find_Element(B_lleg,w_aux[1]):
            if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>                w_res[index_c]:= w_res[index_c] + w_aux[2]*Form1[i]*Form2[j]:
            fi:
         fi: 
      od:
   od:
   return convert(w_res,list):
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Cup Ordenado de dos elementos bases</Font></Text-field></Title><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">sort_cup_nt_nt</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">
Realiza el producto cup entre dos elementos bases [[v1],[v2]], [[v3],[v4]]</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Input</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v1 = [u1,...,uk] con u1&lt;...&lt;uk</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v2 = [v1,...,vl] con v1&lt;...&lt;vl</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v3 = [w1,...,ws] con w1&lt;....&lt;ws
v4 = [z1,...,zt] con z1&lt;...&lt;vt</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">sort_cup_nt_t</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">
Realiza el producto cup entre dos elementos bases [[v1],[v2]], [v3]</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Input</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v1 = [u1,...,uk] con u1&lt;...&lt;uk</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v2 = [v1,...,vl] con v1&lt;...&lt;vl</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v3 = [w1,...,ws] con w1&lt;....&lt;ws</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">b_triv: Bandera para decir donde  pertenece v3</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">sort_cup_t_nt</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">
Realiza el producto cup entre dos elementos bases [v1], [[v2],[v3]]  </Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font underline="true" bold="true" foreground="[0,128,128]">Input</Font><Font foreground="[0,128,128]">:</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v1 = [u1,...,uk] con u1&lt;...&lt;uk</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v2 = [v1,...,vl] con v1&lt;...&lt;vl</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">v3 = [w1,...,ws] con w1&lt;....&lt;ws</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">b_triv: Bandera para decir donde  pertenece v1</Font></Text-field><Text-field style="Text" foreground="[0,128,128]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L1161" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">sort_cup_nt_nt := proc(V1::list , V2::list) :: list:
    local sign_k, aux_list, Res_List:
    local V1_1, V1_2, V2_1, V2_2, W1, W2:
    
    Res_List:=[];
    aux_list:=[];
    
    V1_1:=V1[1]:
    V1_2:=V1[2]:
    V2_1:=V2[1]:
    V2_2:=V2[2]:

    sign_k:=(-1)^(nops(V1_2)*nops(V2_1)):   <Font foreground="[255,102,0]"># El signo de Kuszul</Font>
    
    W1:= sort_wedge(V1_1,V2_1):
    W2:= sort_wedge(V1_2,V2_2):
    
    sign_k:=sign_k*W1[2]*W2[2]: <Font foreground="[255,102,0]"># Puede variar nuevamente por el wedge</Font>

    if W1[1]&lt;&gt;[] and W2[1]&lt;&gt;[] then:
       aux_list:=[op(aux_list),W1[1],W2[1]]:
    fi:
    Res_List := [op(Res_List),aux_list,sign_k]:
    return Res_List:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1160" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=</Equation></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1162" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">sort_cup_nt_t := proc(V1::list , V2::list, b_triv::boolean) :: list:
<Font foreground="[255,102,0]"># Necesito una bandera de control b_triv.
# b_triv = true entonces V2 es trivial sobre los no duales
# b_triv = false entonces V2 es trivial sobre los duales</Font>
    local sign_k, aux_list, Res_List:
    local V1_1, V1_2, W:
    
    Res_List:=[];
    aux_list:=[];
    sign_k:=0:
    
    V1_1:=V1[1]:
    V1_2:=V1[2]:

    if b_triv = true then:
       sign_k:=(-1)^(nops(V1_2)*nops(V2)):   <Font foreground="[255,102,0]"># El signo de Kuszul</Font>
    
       W:= sort_wedge(V1_1,V2):
    
       sign_k:=sign_k*W[2]: <Font foreground="[255,102,0]"># Puede variar nuevamente por el wedge</Font>

       if W[1]&lt;&gt;[] then
          aux_list:=[op(aux_list),W[1],V1_2]:
       fi:
    else:
       
       W:= sort_wedge(V1_2,V2):
    
       sign_k:=W[2]: <Font foreground="[255,102,0]"># Puede variar por el wedge</Font>

       if W[1]&lt;&gt;[] then
          aux_list:=[op(aux_list),V1_1, W[1]]:
       fi:
    fi:
    Res_List := [op(Res_List),aux_list,sign_k]:
    return Res_List:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1165" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=</Equation></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1166" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">sort_cup_t_nt := proc(V1::list , V2::list, b_triv::boolean) :: list:
<Font foreground="[255,102,0]"># Necesito una bandera de control b_triv.
# b_triv = true entonces V1 es trivial sobre los duales
# b_triv = false entonces V1 es trivial sobre los no duales</Font>
    local sign_k, aux_list, Res_List:
    local V2_1, V2_2, W:
    
    Res_List:=[];
    aux_list:=[];
    sign_k:=0:
    
    V2_1:=V2[1]:
    V2_2:=V2[2]:

    if b_triv = true then:

       W:= sort_wedge(V1,V2_1):
    
       sign_k:=W[2]: <Font foreground="[255,102,0]"># Puede variar por el wedge</Font>

       if W[1]&lt;&gt;[] then
          aux_list:=[op(aux_list),W[1],V2_2]:
       fi:
       
    else:

       sign_k:=(-1)^(nops(V1)*nops(V2_1)):   <Font foreground="[255,102,0]"># El signo de Kuszul</Font>
    
       W:= sort_wedge(V1,V2_2):
    
       sign_k:=sign_k*W[2]: <Font foreground="[255,102,0]"># Puede variar nuevamente por el wedge</Font>

       if W[1]&lt;&gt;[] then
          aux_list:=[op(aux_list),V2_1,W[1]]:
       fi:
    fi:
    Res_List := [op(Res_List),aux_list,sign_k]:
    return Res_List:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1167" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=</Equation></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L1168" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">sort_cup_t_t := proc(V1::list , V2::list) :: list:
   
   return sort_wedge(V1,V2): 

end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Cup product de dos elementos sobre </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYsLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEoJiM5MjM7VkYnLyUlc2l6ZUdRIzE0RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lLG1hdGh2YXJpYW50R1ElYm9sZEYnLyUrZm9udHdlaWdodEdGPS1GIzYpLUkjbW9HRiQ2MFEiKkYnRjJGNUY7Rj4vJSZmZW5jZUdGOi8lKnNlcGFyYXRvckdGOi8lKXN0cmV0Y2h5R0Y6LyUqc3ltbWV0cmljR0Y6LyUobGFyZ2VvcEdGOi8lLm1vdmFibGVsaW1pdHNHRjovJSdhY2NlbnRHRjovJSdsc3BhY2VHUSwwLjE2NjY2NjdlbUYnLyUncnNwYWNlR0ZWRjJGNS8lK2V4ZWN1dGFibGVHRjovJTBmb250X3N0eWxlX25hbWVHUSpIZWFkaW5nfjJGJ0Y7Rj4vJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNihRInhGJ0YyRjVGOEY7Rj4tRkM2MFEifkYnRjJGNUY7Rj5GRkZIRkpGTEZORlBGUi9GVVEmMC4wZW1GJy9GWEZib0YuRjJGNUZZRmVuRjtGPg==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYsLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEoJiM5MjM7VkYnLyUlc2l6ZUdRIzE0RicvJSVib2xkR1EldHJ1ZUYnLyUnaXRhbGljR1EmZmFsc2VGJy8lLG1hdGh2YXJpYW50R1ElYm9sZEYnLyUrZm9udHdlaWdodEdGPS1GIzYpLUkjbW9HRiQ2MFEiKkYnRjJGNUY7Rj4vJSZmZW5jZUdGOi8lKnNlcGFyYXRvckdGOi8lKXN0cmV0Y2h5R0Y6LyUqc3ltbWV0cmljR0Y6LyUobGFyZ2VvcEdGOi8lLm1vdmFibGVsaW1pdHNHRjovJSdhY2NlbnRHRjovJSdsc3BhY2VHUSwwLjE2NjY2NjdlbUYnLyUncnNwYWNlR0ZWRjJGNS8lK2V4ZWN1dGFibGVHRjovJTBmb250X3N0eWxlX25hbWVHUSpIZWFkaW5nfjJGJ0Y7Rj4vJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNihRInhGJ0YyRjVGOEY7Rj4tRkM2MFEifkYnRjJGNUY7Rj5GRkZIRkpGTEZORlBGUi9GVVEmMC4wZW1GJy9GWEZib0YuRjJGNUZZRmVuRjtGPg==</Equation></Text-field></Title><Text-field style="Text" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto copa entre dos elementos FormT_1, FormT_2 de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==</Equation><Font foreground="[0,128,128]">

<Font bold="true">Input:</Font>
FormT_1 = [x1,...,xp] donde FormT_1 = x1*FT1 + .... + xp*FTp y cada FTi es un elemento base de  </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==</Equation><Font foreground="[0,128,128]">
FormT_2 = [y1,...,yq] donde FormT_2 = y1*GT1 + .... + yq*GTq y cada GTj es un elemento base de  </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==</Equation><Font foreground="[0,128,128]">
k1,k1,k3,k4 = valores de los wedge de   </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==</Equation><Font foreground="[0,128,128]">
dimV = dimension del espacio V subyacente de los  </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==</Equation></Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field style="Text" layout="Normal"><Font foreground="[0,128,128]">BE = Base Exterior completa
</Font></Text-field><Text-field style="Text" layout="Normal"><Font bold="true" foreground="[0,128,128]">Output:</Font><Font foreground="[0,128,128]">
Coordenadas del cup product  FormT_1 v FormT_2 en </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYnUSJ4RidGMkY1RjhGOy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZbb0YuRjhGOw==</Equation><Font foreground="[0,128,128]">

<Font bold="true">Nota:</Font> En este metodo se supone que existe compatibilidad de dimensiones. Es decir, k1+k3 &lt;= dim(V) y k2+k4 &lt;= dim(V). 
Por lo tanto, el chequeo de esta compatibilidad debe realizarse donde se invoca el metodo. Todo el algoritmo respeta la 
estructura de Base Exterior otorgada por BaseExt(). 

<Font bold="true">cup_nt_nt_BE</Font>: Se pasa como parametros k1,k2,k3,k4, dimV y la base exterior.</Font><Font foreground="[0,128,0]">
</Font></Text-field>
<Group hide-output="false" labelreference="L1169" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">cup_nt_nt_BE := proc(BE, FormT_1::list ,FormT_2::list, k1, k2, k3, k4, dimV) :: list:
   local i, j, w_res, e_b1, e_b2, index_c, w_aux, dim_lleg_1, dim_lleg_2, B_lleg:
   local B_FT_1, B_FT_2:

   B_FT_1 := Basis_of_TensorL(BE[k1], BE[k2]):
   B_FT_2 := Basis_of_TensorL(BE[k3], BE[k4]):

   dim_lleg_1 := binomial(dimV,k1+k3):
   dim_lleg_2 := binomial(dimV,k2+k4):

   B_lleg := Basis_of_TensorL(BE[k1+k3], BE[k2+k4]):

   w_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array): <Font foreground="[255,102,0]"># Coordenadas del cup resultante.
</Font>
   for i from 1 to nops(FormT_1) do:
      for j from 1 to nops(FormT_2) do:
         if FormT_1[i]&lt;&gt;0 and FormT_2[j]&lt;&gt;0 then:

            e_b1 := B_FT_1[i]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[j]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>

            w_aux := sort_cup_nt_nt(e_b1,e_b2):

            index_c:= Find_Element(B_lleg,w_aux[1]):
            if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>                w_res[index_c]:= w_res[index_c] + w_aux[2]*FormT_1[i]*FormT_2[j]:
            fi:
         fi: 
      od:
   od:
   return convert(w_res,list):
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Cup product de un elemento de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYqLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNictSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMkY1RjtGPi8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRictRi82KFEieEYnRjJGNUY4RjtGPi1GQzYwUSJ+RidGMkY1RjtGPkZGRkhGSkZMRk5GUEZSL0ZVUSYwLjBlbUYnL0ZYRl1vRi5GMkY1RjtGPg==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYqLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNictSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMkY1RjtGPi8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRictRi82KFEieEYnRjJGNUY4RjtGPi1GQzYwUSJ+RidGMkY1RjtGPkZGRkhGSkZMRk5GUEZSL0ZVUSYwLjBlbUYnL0ZYRl1vRi5GMkY1RjtGPg==</Equation><Font size="14">  y un elemento de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYsLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNictSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMkY1RjtGPi8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRictRkM2LlEifkYnRjIvRjxRJ25vcm1hbEYnRkZGSEZKRkxGTkZQRlIvRlVRJjAuMGVtRicvRlhGXG8tRi82KFEib0YnRjJGNUY4RjtGPi1GQzYwRmhuRjJGNUY7Rj5GRkZIRkpGTEZORlBGUkZbb0Zdb0Zhby1GLzYoUSgmIzkyMztWRidGMkY1RjhGO0Y+RjJGNUY7Rj4=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYsLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNictSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMkY1RjtGPi8lMXN1cGVyc2NyaXB0c2hpZnRHUSIwRictRkM2LlEifkYnRjIvRjxRJ25vcm1hbEYnRkZGSEZKRkxGTkZQRlIvRlVRJjAuMGVtRicvRlhGXG8tRi82KFEib0YnRjJGNUY4RjtGPi1GQzYwRmhuRjJGNUY7Rj5GRkZIRkpGTEZORlBGUkZbb0Zdb0Zhby1GLzYoUSgmIzkyMztWRidGMkY1RjhGO0Y+RjJGNUY7Rj4=</Equation><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvRjBRJWJvbGRGJy8lK2ZvbnR3ZWlnaHRHRk0=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvRjBRJWJvbGRGJy8lK2ZvbnR3ZWlnaHRHRk0=</Equation></Text-field></Title><Text-field style="Text" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto copa entre un elementos FormT_1 de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2Ji1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGMkY4RjsvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNidRInhGJ0YyRjVGOEY7LUZBNi9RIn5GJ0YyRjhGO0ZERkZGSEZKRkxGTkZQL0ZTUSYwLjBlbUYnL0ZWRltvRi5GMkY4Rjs=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYpLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2Ji1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGMkY4RjsvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNidRInhGJ0YyRjVGOEY7LUZBNi9RIn5GJ0YyRjhGO0ZERkZGSEZKRkxGTkZQL0ZTUSYwLjBlbUYnL0ZWRltvRi5GMkY4Rjs=</Equation><Font foreground="[0,128,128]"> y un elemento FormT_2 de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GQTYtUSFGJ0Y7RkRGRkZIRkpGTEZORlAvRlNRLDAuMjc3Nzc3OGVtRicvRlZGaG5GOEY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GQTYtUSFGJ0Y7RkRGRkZIRkpGTEZORlAvRlNRLDAuMjc3Nzc3OGVtRicvRlZGaG5GOEY7</Equation><Font foreground="[0,128,128]"> o </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2L1EifkYnLyUlc2l6ZUdRIzE0RicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjovJSlzdHJldGNoeUdGOi8lKnN5bW1ldHJpY0dGOi8lKGxhcmdlb3BHRjovJS5tb3ZhYmxlbGltaXRzR0Y6LyUnYWNjZW50R0Y6LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGSS1JI21pR0YkNidRKCYjOTIzO1ZGJ0YvLyUnaXRhbGljR0Y6RjJGNUY1">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2L1EifkYnLyUlc2l6ZUdRIzE0RicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRjovJSlzdHJldGNoeUdGOi8lKnN5bW1ldHJpY0dGOi8lKGxhcmdlb3BHRjovJS5tb3ZhYmxlbGltaXRzR0Y6LyUnYWNjZW50R0Y6LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGSS1JI21pR0YkNidRKCYjOTIzO1ZGJ0YvLyUnaXRhbGljR0Y6RjJGNUY1</Equation><Font foreground="[0,128,128]">
</Font></Text-field>
<Group hide-output="false" labelreference="L1193" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input>
</Input>
</Group>
<Group hide-output="false" labelreference="L1191" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">cup_nt_t_BE := proc(BE, FormT_1::list ,FormT_2::list, k1, k2, k3, band::boolean, dimV) :: list:
   local i, j, w_res, e_b1, e_b2, index_c, w_aux, dim_lleg_1, dim_lleg_2, B_lleg:
   local B_FT_1, B_FT_2:

   B_FT_1 := Basis_of_TensorL(BE[k1], BE[k2]):
   B_FT_2 := BE[k3]:

   if band = true then:
      dim_lleg_1 := binomial(dimV,k1+k3):
      dim_lleg_2 := binomial(dimV,k2):
      B_lleg := Basis_of_TensorL(BE[k1+k3], BE[k2]):
   else:
      dim_lleg_1 := binomial(dimV,k1):
      dim_lleg_2 := binomial(dimV,k2+k3):
      B_lleg := Basis_of_TensorL(BE[k1], BE[k2+k3]):
   fi:

   w_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array): <Font foreground="[255,102,0]"># Coordenadas del cup resultante.
</Font>
   for i from 1 to nops(FormT_1) do:
      for j from 1 to nops(FormT_2) do:
         if FormT_1[i]&lt;&gt;0 and FormT_2[j]&lt;&gt;0 then:

            e_b1 := B_FT_1[i]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[j]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada j de FormT_2</Font>

            w_aux := sort_cup_nt_t(e_b1,e_b2, band):

            index_c:= Find_Element(B_lleg,w_aux[1]):
            if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>                w_res[index_c]:= w_res[index_c] + w_aux[2]*FormT_1[i]*FormT_2[j]:
            fi:
         fi: 
      od:
   od:
   return convert(w_res,list):
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Cup product de un elemento de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYqLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNiUtSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMi9GPFEnbm9ybWFsRicvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUZDNjBRIn5GJ0YyRjVGO0Y+RkZGSEZKRkxGTkZQRlIvRlVRJjAuMGVtRicvRlhGXG8tRi82KFEib0YnRjJGNUY4RjtGPkZobkZobi1GLzYoUSgmIzkyMztWRidGMkY1RjhGO0Y+RjJGWQ==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYqLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNiUtSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMi9GPFEnbm9ybWFsRicvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUZDNjBRIn5GJ0YyRjVGO0Y+RkZGSEZKRkxGTkZQRlIvRlVRJjAuMGVtRicvRlhGXG8tRi82KFEib0YnRjJGNUY4RjtGPkZobkZobi1GLzYoUSgmIzkyMztWRidGMkY1RjhGO0Y+RjJGWQ==</Equation><Font size="14">  y un elemento de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNiUtSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMi9GPFEnbm9ybWFsRicvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNihRInhGJ0YyRjVGOEY7Rj4tRkM2MFEifkYnRjJGNUY7Rj5GRkZIRkpGTEZORlBGUi9GVVEmMC4wZW1GJy9GWEZfb0YuRjJGWQ==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2KFEqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJWJvbGRHUSV0cnVlRicvJSdpdGFsaWNHUSZmYWxzZUYnLyUsbWF0aHZhcmlhbnRHUSVib2xkRicvJStmb250d2VpZ2h0R0Y9LUYjNiUtSSNtb0dGJDYwUSIqRidGMkY1RjtGPi8lJmZlbmNlR0Y6LyUqc2VwYXJhdG9yR0Y6LyUpc3RyZXRjaHlHRjovJSpzeW1tZXRyaWNHRjovJShsYXJnZW9wR0Y6LyUubW92YWJsZWxpbWl0c0dGOi8lJ2FjY2VudEdGOi8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlZGMi9GPFEnbm9ybWFsRicvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUYvNihRInhGJ0YyRjVGOEY7Rj4tRkM2MFEifkYnRjJGNUY7Rj5GRkZIRkpGTEZORlBGUi9GVVEmMC4wZW1GJy9GWEZfb0YuRjJGWQ==</Equation></Text-field></Title><Text-field style="Text" layout="Normal"><Font foreground="[0,128,128]">Realiza el producto copa entre un elementos FormT_1 de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2Ji1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGMkY4RjsvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUZBNi9RIn5GJ0YyRjhGO0ZERkZGSEZKRkxGTkZQL0ZTUSYwLjBlbUYnL0ZWRmhuRjJGOEY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2Ji1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGMkY4RjsvJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnLUZBNi9RIn5GJ0YyRjhGO0ZERkZGSEZKRkxGTkZQL0ZTUSYwLjBlbUYnL0ZWRmhuRjJGOEY7</Equation><Font foreground="[0,128,128]">o </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2Ji1JI21vR0YkNi1RIUYnRjsvJSZmZW5jZUdGNy8lKnNlcGFyYXRvckdGNy8lKXN0cmV0Y2h5R0Y3LyUqc3ltbWV0cmljR0Y3LyUobGFyZ2VvcEdGNy8lLm1vdmFibGVsaW1pdHNHRjcvJSdhY2NlbnRHRjcvJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZURjJGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZobkYyRjhGOw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2Ji1JI21vR0YkNi1RIUYnRjsvJSZmZW5jZUdGNy8lKnNlcGFyYXRvckdGNy8lKXN0cmV0Y2h5R0Y3LyUqc3ltbWV0cmljR0Y3LyUobGFyZ2VvcEdGNy8lLm1vdmFibGVsaW1pdHNHRjcvJSdhY2NlbnRHRjcvJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZURjJGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GQTYvUSJ+RidGMkY4RjtGREZGRkhGSkZMRk5GUC9GU1EmMC4wZW1GJy9GVkZobkYyRjhGOw==</Equation><Font foreground="[0,128,128]"> y un elemento FormT_2 de </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYoUSJ4RidGMkY1RjgvJTBmb250X3N0eWxlX25hbWVHUSkyRH5JbnB1dEYnRjstRkE2MFEifkYnRjJGOEZnbkY7RkRGRkZIRkpGTEZORlAvRlNRJjAuMGVtRicvRlZGXm8tRi82KFEoJiM5MjM7VkYnRjJGNUY4RmduRjtGOEY7">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUklbXN1cEdGJDYlLUkjbWlHRiQ2J1EqJkxhbWJkYTtWRicvJSVzaXplR1EjMTRGJy8lJ2l0YWxpY0dRJmZhbHNlRicvJStmb3JlZ3JvdW5kR1EsWzAsMTI4LDEyOF1GJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRictRiM2JS1JI21vR0YkNi9RIipGJ0YyRjhGOy8lJmZlbmNlR0Y3LyUqc2VwYXJhdG9yR0Y3LyUpc3RyZXRjaHlHRjcvJSpzeW1tZXRyaWNHRjcvJShsYXJnZW9wR0Y3LyUubW92YWJsZWxpbWl0c0dGNy8lJ2FjY2VudEdGNy8lJ2xzcGFjZUdRLDAuMTY2NjY2N2VtRicvJSdyc3BhY2VHRlRGOEY7LyUxc3VwZXJzY3JpcHRzaGlmdEdRIjBGJy1GLzYoUSJ4RidGMkY1RjgvJTBmb250X3N0eWxlX25hbWVHUSkyRH5JbnB1dEYnRjstRkE2MFEifkYnRjJGOEZnbkY7RkRGRkZIRkpGTEZORlAvRlNRJjAuMGVtRicvRlZGXm8tRi82KFEoJiM5MjM7VkYnRjJGNUY4RmduRjtGOEY7</Equation><Font foreground="[0,128,128]"> </Font><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYkLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkNGLw==">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYkLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkNGLw==</Equation><Font foreground="[0,128,128]">
</Font></Text-field>
<Group hide-output="false" labelreference="L1198" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input>
</Input>
</Group>
<Group hide-output="false" labelreference="L1197" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">cup_t_nt_BE := proc(BE, FormT_1::list ,FormT_2::list, k1, k2, k3, band::boolean, dimV) :: list:
   local i, j, w_res, e_b1, e_b2, index_c, w_aux, dim_lleg_1, dim_lleg_2, B_lleg:
   local B_FT_1, B_FT_2:

   B_FT_1 := BE[k1]:
   B_FT_2 := Basis_of_TensorL(BE[k2], BE[k3]):

   if band = true then:
      dim_lleg_1 := binomial(dimV,k1+k2):
      dim_lleg_2 := binomial(dimV,k3):
      B_lleg := Basis_of_TensorL(BE[k1+k2], BE[k3]):
   else:
      dim_lleg_1 := binomial(dimV,k2):
      dim_lleg_2 := binomial(dimV,k1+k3):
      B_lleg := Basis_of_TensorL(BE[k2], BE[k1+k3]):
   fi:

   w_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array): <Font foreground="[255,102,0]"># Coordenadas del cup resultante.
</Font>
   for i from 1 to nops(FormT_1) do:
      for j from 1 to nops(FormT_2) do:
         if FormT_1[i]&lt;&gt;0 and FormT_2[j]&lt;&gt;0 then:

            e_b1 := B_FT_1[i]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[j]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada j de FormT_2</Font>

            w_aux := sort_cup_t_nt(e_b1,e_b2, band):

            index_c:= Find_Element(B_lleg,w_aux[1]):
            if index_c &lt;&gt; -1 then<Font foreground="[255,204,0]">
</Font>                w_res[index_c]:= w_res[index_c] + w_aux[2]*FormT_1[i]*FormT_2[j]:
            fi:
         fi: 
      od:
   od:
   return convert(w_res,list):
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Mostrar en pantalla el resultado de un producto copa</Font></Text-field></Title>
<Group hide-output="false" labelreference="L2125" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Mostrar_Copa := proc(Vec1, Vec2, RCup, bas1, bas2, bas3)
    local i, v_formal_1, v_formal_2, cup_formal:

    v_formal_1 := Combinacion_Formal(Vec1, bas1): 
    v_formal_2 := Combinacion_Formal(Vec2, bas2): 
    cup_formal := Combinacion_Formal(RCup, bas3):

    if cup_formal &lt;&gt; 0 then:
       <Font encoding="UTF-8">print(v_formal_1, ` \302\253\302\273 </Font>`, v_formal_2, ` = `, cup_formal): 
       print(`            `):
    fi:
end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2138" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Mostrar_Repr_Copa:=proc(Vec1, Vec2, RepCup, bas1, bas2, bas3)
    local i, v_formal_1, v_formal_2, cup_formal:

    v_formal_1 := Combinacion_Formal(Vec1, bas1): 
    v_formal_2 := Combinacion_Formal(Vec2, bas2): 
    cup_formal := Vectores_Formal(RepCup, bas3):
    if cup_formal &lt;&gt; [] then:
        print(v_formal_1, ` <Font encoding="UTF-8">\302\253\302\273</Font> `, v_formal_2, ` = `, cup_formal): 
        print(`            `):
    fi:

end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2160" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Invariantes adjuntos sobre Wedge^2(L)</Text-field></Title>
<Group labelreference="L3514" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,102,0]"># Se quiere calcular un L-invariante en Wedge^2(L). Definimos Omega como un elemento en 
<Font encoding="UTF-8"># Wedge^2(L) y hacemos actuar a L sobre Omega (por derivaci\303\263n) a travez de la adjunta.
</Font># Parametros:
# L: tabla de multiplicar del algebra
# BE: Base exterior completa de L
# <Font opaque="true" background="[204,255,204]">Nota: En BE[2] se encuentran los indices para usar con VC.</Font><Font opaque="true" background="[204,255,255]">
</Font></Font>
Invariantes_Wedge2 := proc(L, BE) 
local i,j, dimL, dimW2, W2_aux, Ecu_W2, VC, Omega, p_ind, sum1, sum2, Vec_null: 

dimL := nops(L[1,1]):       <Font foreground="[51,102,255]"># Dimension de L</Font>
<Font foreground="[128,0,0]">VC   := Canonicos(dimL): </Font><Font foreground="[51,102,255]">   # Representan los vectores de L 
</Font>
dimW2   := nops(BE[2]):                         <Font foreground="[51,102,255]"># Dimension de Wedge^2(L)</Font>
Vec_null:= convert(Vector(1..dimW2, 0), list):  <Font foreground="[51,102,255]"># Vector nulo en Wedge^2(L)</Font>

<Font foreground="[128,0,0]">Omega  := </Font>[seq(b||i,i=1..dimW2)]<Font foreground="[128,0,0]">:</Font><Font foreground="[51,102,255]"> # Elemento en Wedge^2(L) 
</Font><Font foreground="[128,0,0]">Ecu_W2 := {}:                     </Font><Font foreground="[51,102,255]"># Ecuaciones para ser invariante en Wedge^2(L)</Font>

for i from 1 to dimL do:
   <Font foreground="[51,102,255]">W2_aux := Vec_null:</Font>
   for j from 1 to dimW2 do:

      p_ind := BE[2][j]:

      sum1 := form_wedge_BE(BE, L[i,p_ind[1] ], VC[ p_ind[2] ], 1, 1, dimL):
      sum2 := form_wedge_BE(BE, VC[ p_ind[1] ], L[i,p_ind[2] ], 1, 1, dimL):

      W2_aux := W2_aux + Prod_param_list(Omega[j],sum1) + Prod_param_list(Omega[j],sum2):

   od:
   Ecu_W2 := Ecu_W2 union convert(W2_aux,set):
od:

return Ecu_W2:

end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Rutinas para Corchete de Poisson</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Conversion de elemento base a coordenadas</Font></Text-field></Title>
<Group labelreference="L2283" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># Convierte un elemento base de un Wedge en coordenadas del Wedge</Font>

conv_bas2coord := proc(BE,e_bas,dimV)
local dim_lleg, coord_res, B_lleg, pos:
coord_res := []:
if e_bas &lt;&gt; [] then:   
   dim_lleg := binomial(dimV,nops(e_bas)):
   coord_res := convert(Vector(1 .. (dim_lleg), 0), Array):
   B_lleg := BE[nops(e_bas)]:
   pos := Find_Element(B_lleg,e_bas):
   if pos &lt;&gt; -1 then 
      coord_res[pos] := 1 
   fi:
fi:
return convert(coord_res,list):
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Evaluacion de Poisson</Font></Text-field></Title><Text-field style="Text" foreground="[51,102,255]" layout="Normal"><Font underline="true" foreground="[255,102,0]">eval_f_b:</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Realiza la evaluacion entre dos elementos bases e1, e2 del siguiente modo:</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">* Si e1 es un funcional base y e2 un vector base (o viceversa) entonces devuelve 1 cuando ambos coinciden o cero en todo caso.</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">* Si e1 y e2 son elementos del mismo espacio entonces retorna cero.</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Para saber que e1 y e2 se usa una bandera de control exterior band: Si band = true entonces e1 y e2 son de diferentes espacios.</Font></Text-field><Text-field style="Text" foreground="[51,102,255]" layout="Normal"><Font foreground="[51,153,102]">Se debe tener presente que V = [[1],[2],.....,[n]] y V* = [[1],[2],.....,[n]] de manera que el dual de [1] es [1], el dual de [2] es [2], etc.</Font><Font foreground="[51,102,255]">

</Font></Text-field><Text-field style="Text" foreground="[51,102,255]" layout="Normal"><Font underline="true" foreground="[255,102,0]">eval_Pois_1:</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Realiza el corchete de Poisson entre dos elementos bases v1, v2, donde:</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">v1 es un elemento base en el wedge(V) o wedge(V*) y v2 es un elemento base en V* o V (o viceversa)</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Retorna un elemento de la forma [p_res,sign] donde p_res es un elemento base y sign indica el signo del producto de Poisson.</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Si p_res = [ ] entonces hay que leer sign para saber si el producto fue nulo o no: Si sign = 0 entonces el producto fue nulo, caso</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">contrario quiere decir que se realizo de producto de Poisson entre un elemento base y su dual respectivamente.</Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Estudiando los signos de Koszul sobre los axiomas del bracket, se logra ver que: </Font></Text-field><Text-field style="Text" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">* Si |v2| = 1 entonces {v1,v2} = (-1)^( p2 + |v1|)*v1_2, donde p2 es la posicion donde ocurre v2 en v1 y v1_2 es el nuevo elemento
   base obtenido de v1 eliminando v2.
* Si |v1| = 1 entonces {v1,v2} = (-1)^(|v2| +1){v2,v1} = (-1)^(|v2| +1) (-1)^( p1 + |v2|)*v2_1 =  (-1)^( p1 + 1)*v2_1</Font></Text-field><Text-field style="Text" foreground="[51,102,255]" layout="Normal"></Text-field>
<Group hide-output="false" labelreference="L2168" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">eval_f := proc(e1,e2) :: int:
local P_res:
P_res := 0:
if e1 = e2 then P_res := 1: fi:
 
return P_res:
end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2234" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">eval_f_b := proc(e1,e2, band) :: int:
local P_res:
P_res := 0:
if band = true and e1 = e2 then P_res := 1: fi:
 
return P_res:
end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2169" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2218" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">eval_Pois_1:= proc(v1::list, v2::list)
local p_res, index, sign:
sign := 0:
p_res := []: 
if nops(v2) = 1 then:
   index := Find_Element(v1,v2[1]):
   if index &lt;&gt; -1 then:
      sign := (-1)^(index+nops(v1)):
      p_res := subsop(index = NULL, v1):
   fi:
elif nops(v1) = 1 then:
   index := Find_Element(v2,v1[1]):
   if index &lt;&gt; -1 then:
      sign := (-1)^(index+1):
      p_res := subsop(index = NULL, v2):
   fi:
fi:

return [p_res,sign]:
end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2231" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font bold="false" foreground="[255,153,0]"># En este metodo supongo que siempre v1 es un funcional base y v2 es un vector base.
# Por lo tanto se evaluan coordenadas de v1 en v2 y se usa el metodo anterior.</Font>

eval_Pois_2a := proc(BE, v1::list, v2::list, dimV)
local k1, k2, dim1, dim2, dim_lleg, B_lleg, ii, p_aux, w_1, w_2, c_lleg, sign_aux, coord_res: 

k1 := nops(v1):
k2 := nops(v2):
dim1 := binomial(dimV,k1-1):
dim2 := binomial(dimV,k2-1):
dim_lleg := dim1*dim2:

coord_res := convert(Vector(1 .. (dim_lleg), 0), Array):

if k1 &lt;&gt; 0 and k2 &lt;&gt; 0 then:
   B_lleg := Basis_of_TensorL(BE[k1-1], BE[k2-1]):
   for ii from 1 to k1 do:
      p_aux := eval_Pois_1([v1[ii]],v2):
      if p_aux[2] &lt;&gt; 0 then: <Font foreground="[255,153,0]"># Se pregunta si el producto es cero</Font>
         w_1 := subsop(ii = NULL, v1):
         w_2 := p_aux[1]:
         c_lleg := Find_Element(B_lleg,[w_1,w_2]): <Font foreground="[255,153,0]"># Busco la posicion del elemento base de llegada</Font>
         if c_lleg &lt;&gt; -1 then:
            sign_aux := (-1)^(ii+k1)*p_aux[2]:
            coord_res[c_lleg] := sign_aux:
         fi:
      fi:
   od:
fi:
<Font foreground="[128,0,0]">return convert(coord_res,list):
</Font>end proc:

<Font bold="false" foreground="[255,153,0]"># Para especificar cual vector base corresponde a funcionales, se usa una variable
# auxiliar de control ind_f: si ind_f = 1 entonces v1 son funcionales y si ind_f = 2
# entonces v2 son funcionales. Luego se invoca el metodo anterior con cambios de signos.</Font>

eval_Pois_2b := proc(BE, v1::list, v2::list, dimV, ind_f)
local sign_aux, coord_res: 

if ind_f = 1 then:
   coord_res := eval_Pois_2a(BE,v1,v2,dimV):
elif ind_f = 2 then:
   coord_res := (-1)^(nops(v1)*nops(v2)+1)*eval_Pois_2a(BE,v2,v1,dimV):
else:
   coord_res := eval_Pois_2b(BE, v1, v2, dimV, 1):
fi:
return coord_res:
end proc:

</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2244" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" bold="false" foreground="[51,153,102]" layout="Normal"><Font bold="true" foreground="[255,102,0]">#------------------------------------------------------------------------#</Font><Font bold="false" foreground="[51,153,102]">
</Font><Font bold="true" foreground="[255,102,0]"># No borrar estos ejemplos

</Font><Font bold="true" foreground="[51,153,102]">eval_Pois_1([1,3,5,6],[6]), eval_Pois_1([6],[1,3,5,6]);
eval_Pois_1([2],[2]);</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkobWZlbmNlZEdGJDYmLUYjNigtRiw2Ji1GIzYqLUkjbW5HRiQ2JFEiMUYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RIixGJ0Y4LyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRkEvJSpzeW1tZXRyaWNHRkEvJShsYXJnZW9wR0ZBLyUubW92YWJsZWxpbWl0c0dGQS8lJ2FjY2VudEdGQS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnLUY1NiRRIjNGJ0Y4RjstRjU2JFEiNUYnRjgvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRkFGOEY4LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRjtGNEZlbkZobkY4RjhGam5GXW9GOy1GLDYmLUYjNihGMEY7LUYjNiUtRjw2LVEqJnVtaW51czA7RidGOEY/L0ZDRkFGRUZHRklGS0ZNL0ZQUSwwLjIyMjIyMjJlbUYnL0ZTRltwRjRGOEZlbkZobkY4RjhGam5GXW9GZW5GaG5GOA==">NiQ3JDclIiIiIiIkIiImRiU3JEYkISIi</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2Ji1JI21vR0YkNi1RIUYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGOy8lKXN0cmV0Y2h5R0Y7LyUqc3ltbWV0cmljR0Y7LyUobGFyZ2VvcEdGOy8lLm1vdmFibGVsaW1pdHNHRjsvJSdhY2NlbnRHRjsvJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZKLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y7RjZGNi8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1GMzYtUSIsRidGNkY5L0Y9USV0cnVlRidGPkZARkJGREZGL0ZJUSYwLjBlbUYnL0ZMUSwwLjMzMzMzMzNlbUYnLUkjbW5HRiQ2JFEiMUYnRjZGTUZQRjZGNkZSRlU=">NyQ3IiIiIg==</Equation></Text-field>
</Output>
</Group>
<Group hide-output="false" labelreference="L2269" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">BExt := BaseExt(4):
</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2229" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">eval_Pois_2a(BExt,[1,2,3],[1,2],4);</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDZULUkjbW5HRiQ2JFEiMEYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RIixGJ0YyLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRjsvJSpzeW1tZXRyaWNHRjsvJShsYXJnZW9wR0Y7LyUubW92YWJsZWxpbWl0c0dGOy8lJ2FjY2VudEdGOy8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnLUYvNiRRIjFGJ0YyRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Rk9GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGO0YyRjIvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRic=">NzoiIiEiIiJGI0YjRiNGI0YjRiNGI0YkRiNGI0YjRiNGI0YjRiNGI0YjRiNGI0YjRiNGIw==</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2251" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">eval_Pois_2b(BExt,[1,2,3],[1,2],4,1);</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDZULUkjbW5HRiQ2JFEiMEYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RIixGJ0YyLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRjsvJSpzeW1tZXRyaWNHRjsvJShsYXJnZW9wR0Y7LyUubW92YWJsZWxpbWl0c0dGOy8lJ2FjY2VudEdGOy8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnLUYvNiRRIjFGJ0YyRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Rk9GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGO0YyRjIvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRic=">NzoiIiEiIiJGI0YjRiNGI0YjRiNGI0YkRiNGI0YjRiNGI0YjRiNGI0YjRiNGI0YjRiNGIw==</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2250" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">eval_Pois_2b(BExt,[1,2,3],[1,2],4,2);</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDZULUkjbW5HRiQ2JFEiMEYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RIixGJ0YyLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRjsvJSpzeW1tZXRyaWNHRjsvJShsYXJnZW9wR0Y7LyUubW92YWJsZWxpbWl0c0dGOy8lJ2FjY2VudEdGOy8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnRi5GNUYuRjVGLkY1LUYvNiRRIjFGJ0YyRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUZPRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGO0YyRjIvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRic=">NzoiIiFGI0YjRiMiIiJGI0YjRiNGI0YjRiNGI0YjRiRGI0YjRiNGI0YjRiNGI0YjRiNGIw==</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2227" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" bold="false" foreground="[255,102,0]" layout="Normal"><Font bold="true" foreground="[255,102,0]">#------------------------------------------------------------------------#</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Corchete de Poisson de dos elementos Bases no triviales</Font></Text-field></Title>
<Group hide-input="false" hide-output="false" labelreference="L2181" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># Este metodo calcula el Bracket de Poisson de dos elementos bases [v11,v12] y [v21,v22]
# Ojo: en este metodo [] es interpretado como cero.</Font>

Poiss_nt_nt := proc(BE, v1::list , v2::list, dimV)
local sign_1, sign_2, coord_res, pois_1, pois_2, cup_1, cup_2, cup_pois_1, cup_pois_2:
local v11, v12, v21, v22, k11, k12, k21, k22, c11, c12, c21, c22, dim_lleg:

v11:=v1[1]:  k11 := nops(v11): # print(v11,k11):
v12:=v1[2]:  k12 := nops(v12): # print(v12,k12):
v21:=v2[1]:  k21 := nops(v21): # print(v21,k21):
v22:=v2[2]:  k22 := nops(v22): # print(v22,k22):

dim_lleg := binomial(dimV,k11+k21-1)*binomial(dimV,k12+k22-1):

cup_pois_1 := convert(Vector(1 .. dim_lleg, 0), Array): 
cup_pois_2 := convert(Vector(1 .. dim_lleg, 0), Array): 
coord_res := convert(Vector(1 .. (dim_lleg), 0), Array): 

sign_1 := (-1)^(k12*(k21 + k22) + k21*k22 + 1):
sign_2 := (-1)^((k11+k12)*k21 + k11*k12):

c11:=conv_bas2coord(BE,v11,dimV):
c12:=conv_bas2coord(BE,v12,dimV):
c21:=conv_bas2coord(BE,v21,dimV):
c22:=conv_bas2coord(BE,v22,dimV):

pois_1 := eval_Pois_2a(BE, v21, v12, dimV):
pois_2 := eval_Pois_2a(BE, v11, v22, dimV):
   
if pois_1 &lt;&gt; [] then:
   cup_1 := cup_nt_nt_BE(BE, c11 ,c22 , k11, 0, 0, k22, dimV):
   if cup_1 &lt;&gt; [] then:
      cup_pois_1 := Array(sign_1*cup_nt_nt_BE(BE, cup_1 ,pois_1 , k11, k22, k21-1, k12-1, dimV)):   
   fi:
fi:

if pois_2 &lt;&gt; [] then:
   cup_2 := cup_nt_nt_BE(BE, c21 ,c12 , k21, 0, 0, k12, dimV):
   if cup_2 &lt;&gt; [] then:
      cup_pois_2 := Array(sign_2*cup_nt_nt_BE(BE, cup_2 ,pois_2 , k21, k12, k11-1, k22-1, dimV)):
   fi:
fi:
coord_res := coord_res + cup_pois_1 + cup_pois_2:
return convert(coord_res,list):
end proc:
</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2182" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># Este metodo calcula el corchete de Poisson de dos elementos bases v1 y [v21,v22]
# Aqui v1 puede ser wedge de funcionales o wedge de vectores, por lo que se usa una
# bandera de control para especificar que tipo es v1:
# Si b_v1 = true entonces v1 es wedge de funcionales 
# Si b_v2 = false entonces v1 es wedge de vectores:</Font>

Poiss_t_nt := proc(BE, v1::list, b_v1, v2::list, dimV)
local sign_a, coord_res, pois_a, cup_a, cup_pois_a:
local v21, v22, k1, k21, k22, c1, c21, c22, dim_lleg:

k1 := nops(v1):
v21:=v2[1]:  k21 := nops(v21): # print(v21,k21):
v22:=v2[2]:  k22 := nops(v22): # print(v22,k22):

if b_v1 = true then:

   dim_lleg := binomial(dimV,k1 + k21-1)*binomial(dimV,k22-1):

   cup_pois_a := convert(Vector(1 .. dim_lleg, 0), Array): 
   coord_res := convert(Vector(1 .. (dim_lleg), 0), Array): 

   sign_a := (-1)^(k1*k21):

   c1:=conv_bas2coord(BE,v1,dimV): 
   c21:=conv_bas2coord(BE,v21,dimV):
   c22:=conv_bas2coord(BE,v22,dimV):

   pois_a := eval_Pois_2a(BE, v1, v22, dimV):
   
   if pois_a &lt;&gt; [] then:
      cup_pois_a := Array(sign_a*cup_t_nt_BE(BE, c21, pois_a, k21, k1-1, k22-1, true, dimV)):   
   fi:

else:

   dim_lleg := binomial(dimV,k21-1)*binomial(dimV,k1 + k22-1):

   cup_pois_a := convert(Vector(1 .. dim_lleg, 0), Array): 
   coord_res := convert(Vector(1 .. (dim_lleg), 0), Array): 

   sign_a := (-1)^(k1*(k21+k22) + k21*k22 +1):

   c1:=conv_bas2coord(BE,v1,dimV): 
   c21:=conv_bas2coord(BE,v21,dimV):
   c22:=conv_bas2coord(BE,v22,dimV):

   pois_a := eval_Pois_2a(BE, v21, v1, dimV):
   
   if pois_a &lt;&gt; [] then:
      cup_pois_a := Array(sign_a*cup_t_nt_BE(BE, c22, pois_a, k22, k21-1, k1-1, false, dimV)):   
   fi:

fi:
coord_res := coord_res + cup_pois_a:
return convert(coord_res,list):
end proc:
</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2183" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,102,0]">#------------------------------------------------------------------------#</Font></Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2268" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">BExt := BaseExt(4):

vv1 := conv_bas2coord(BExt,[1,2],4);
vv2 := conv_bas2coord(BExt,[3],4);
vv3 := conv_bas2coord(BExt,[3],4);
vv4 := conv_bas2coord(BExt,[2],4);</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkdnYxRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2MC1JI21uR0YkNiRRIjFGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkhGSi9GTlEsMC4zMzMzMzMzZW1GJy1GVTYkUSIwRidGOUZYRmhuRlhGaG5GWEZobkZYRmhuLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y9RjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Zbb0Zeb0Y5">NygiIiIiIiFGJEYkRiRGJA==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkdnYyRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2LC1JI21uR0YkNiRRIjBGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkhGSi9GTlEsMC4zMzMzMzMzZW1GJ0ZURlgtRlU2JFEiMUYnRjlGWEZULyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y9RjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Zbb0Zeb0Y5">NyYiIiFGIyIiIkYj</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkdnYzRicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2LC1JI21uR0YkNiRRIjBGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkhGSi9GTlEsMC4zMzMzMzMzZW1GJ0ZURlgtRlU2JFEiMUYnRjlGWEZULyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y9RjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Zbb0Zeb0Y5">NyYiIiFGIyIiIkYj</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEkdnY0RicvJSdpdGFsaWNHUSV0cnVlRicvJSxtYXRodmFyaWFudEdRJ2l0YWxpY0YnLUkjbW9HRiQ2LVEqfiYjODc4ODt+RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2LC1JI21uR0YkNiRRIjBGJ0Y5LUY2Ni1RIixGJ0Y5RjsvRj9GMUZARkJGREZGRkhGSi9GTlEsMC4zMzMzMzMzZW1GJy1GVTYkUSIxRidGOUZYRlRGWEZULyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y9RjlGOS8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJ0Zbb0Zeb0Y5">NyYiIiEiIiJGI0Yj</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2263" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">sort_cup_nt_nt([[1,2],[]],[[],[3]]);
cup_nt_nt_BE(BExt, vv1 ,vv2 , 2, 0, 0, 1, 4);
sort_cup_nt_nt([[3],[]],[[],[2]]);
cup_nt_nt_BE(BExt, vv3 ,vv4 , 1, 0, 0, 1, 4);</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1GIzYmLUYsNigtSSNtbkdGJDYkUSIxRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUkjbW9HRiQ2LVEiLEYnRjovJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHUSV0cnVlRicvJSlzdHJldGNoeUdGQy8lKnN5bW1ldHJpY0dGQy8lKGxhcmdlb3BHRkMvJS5tb3ZhYmxlbGltaXRzR0ZDLyUnYWNjZW50R0ZDLyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdRLDAuMzMzMzMzM2VtRictRjc2JFEiMkYnRjovJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRkNGOkY6LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRj0tRiM2Ji1GLDYmLUY3NiRRIjNGJ0Y6RlpGZ25GOkY6RmluRlxvRlpGZ25GOkY6RmluRlxvRj1GNkZaRmduRjpGOkZpbkZcbw==">NyQ3JDckIiIiIiIjNyMiIiRGJQ==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDZULUkjbW5HRiQ2JFEiMEYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RIixGJ0YyLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRjsvJSpzeW1tZXRyaWNHRjsvJShsYXJnZW9wR0Y7LyUubW92YWJsZWxpbWl0c0dGOy8lJ2FjY2VudEdGOy8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnRi5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjUtRi82JFEiMUYnRjJGNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLi8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGO0YyRjIvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRic=">NzoiIiFGI0YjRiNGI0YjRiNGI0YjRiNGI0YjIiIiRiNGI0YjRiNGI0YjRiNGI0YjRiNGIw==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2KC1GIzYmLUYsNiYtSSNtbkdGJDYkUSIzRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R1EmZmFsc2VGJ0Y6RjovJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRictSSNtb0dGJDYtUSIsRidGOi8lJmZlbmNlR0ZCLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRkIvJSpzeW1tZXRyaWNHRkIvJShsYXJnZW9wR0ZCLyUubW92YWJsZWxpbWl0c0dGQi8lJ2FjY2VudEdGQi8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnLUYjNiYtRiw2Ji1GNzYkUSIyRidGOkY9RkBGOkY6RkNGRkY9RkBGOkY6RkNGRkZJLUY3NiRRIjFGJ0Y6Rj1GQEY6RjpGQ0ZG">NyQ3JDcjIiIkNyMiIiMiIiI=</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDZELUkjbW5HRiQ2JFEiMEYnLyUsbWF0aHZhcmlhbnRHUSdub3JtYWxGJy1JI21vR0YkNi1RIixGJ0YyLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR1EldHJ1ZUYnLyUpc3RyZXRjaHlHRjsvJSpzeW1tZXRyaWNHRjsvJShsYXJnZW9wR0Y7LyUubW92YWJsZWxpbWl0c0dGOy8lJ2FjY2VudEdGOy8lJ2xzcGFjZUdRJjAuMGVtRicvJSdyc3BhY2VHUSwwLjMzMzMzMzNlbUYnRi5GNUYuRjVGLkY1Ri5GNUYuRjUtRi82JFEiMUYnRjJGNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri5GNUYuRjVGLkY1Ri4vJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRjtGMkYyLyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYn">NzIiIiFGI0YjRiNGI0YjIiIiRiNGI0YjRiNGI0YjRiNGI0Yj</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2266" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Poi1 := Poiss_t_nt(BExt, [2,3], true, [[1],[2]], 4);
Combinacion_Formal(Poi1, Basis_of_TensorC(BExt[2],BExt[0]));</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVElUG9pMUYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKn4mIzg3ODg7fkYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0ZMLUkobWZlbmNlZEdGJDYmLUYjNjAtSSNtbkdGJDYkUSIwRidGOS1GNjYtUSIsRidGOUY7L0Y/RjFGQEZCRkRGRkZIRkovRk5RLDAuMzMzMzMzM2VtRictRiM2JS1GNjYtUSomdW1pbnVzMDtGJ0Y5RjtGPkZARkJGREZGRkgvRktRLDAuMjIyMjIyMmVtRicvRk5GXm8tRlU2JFEiMUYnRjlGOUZYRlRGWEZURlhGVEZYRlQvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnRmNvRmZvRjk=">NygiIiEhIiJGI0YjRiNGIw==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbW9HRiQ2LVEqJnVtaW51czA7RicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjIyMjIyMmVtRicvJSdyc3BhY2VHRkMtRiM2Ki1JKG1mZW5jZWRHRiQ2Ji1GIzYoLUkjbW5HRiQ2JFEiMUYnRi8tRiw2LVEiLEYnRi9GMi9GNlEldHJ1ZUYnRjdGOUY7Rj1GPy9GQlEmMC4wZW1GJy9GRVEsMC4zMzMzMzMzZW1GJy1GTjYkUSIzRidGLy8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGNEYvRi8vJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRictSSdtc3BhY2VHRiQ2Ji8lJ2hlaWdodEdRJjAuMGV4RicvJSZ3aWR0aEdRJjAuNWVtRicvJSZkZXB0aEdGZ28vJSpsaW5lYnJlYWtHUSVhdXRvRictRiw2LVEiLkYnRi9GMkY1RjdGOUY7Rj1GP0ZWL0ZFRldGYm8tRkk2Ji1GIzYmLUYsNi1RIUYnRi9GMkY1RjdGOUY7Rj1GPy9GQlEsMC4yNzc3Nzc4ZW1GJy9GRUZccUZnbkZqbkYvRi9GXG9GX29GZ25Gam5GL0ZnbkZqbkYv">LCQtSSIuRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiQ3JCIiIiIiJDciISIi</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2267" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Poi2 := Poiss_nt_nt(BExt, [[3],[1]], [[1],[3]] , 4);
Combinacion_Formal(Poi2, Basis_of_TensorC(BExt[1],BExt[1]));</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVElUG9pMkYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKn4mIzg3ODg7fkYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0ZMLUkobWZlbmNlZEdGJDYmLUYjNkQtRiM2JS1GNjYtUSomdW1pbnVzMDtGJ0Y5RjtGPkZARkJGREZGRkgvRktRLDAuMjIyMjIyMmVtRicvRk5GWi1JI21uR0YkNiRRIjFGJ0Y5RjktRjY2LVEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSEZKL0ZOUSwwLjMzMzMzMzNlbUYnLUZnbjYkUSIwRidGOUZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZmbkZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgb0ZqbkZgby8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGY29GZm9GOQ==">NzIhIiIiIiFGJEYkRiRGJEYkRiRGJEYkIiIiRiRGJEYkRiRGJA==</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbW9HRiQ2LVEqJnVtaW51czA7RicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjIyMjIyMmVtRicvJSdyc3BhY2VHRkMtRiM2Ki1JKG1mZW5jZWRHRiQ2Ji1GIzYmLUkjbW5HRiQ2JFEiMUYnRi8vJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRjRGL0YvLyUlb3BlbkdRIltGJy8lJmNsb3NlR1EiXUYnLUknbXNwYWNlR0YkNiYvJSdoZWlnaHRHUSYwLjBleEYnLyUmd2lkdGhHUSYwLjVlbUYnLyUmZGVwdGhHRltvLyUqbGluZWJyZWFrR1ElYXV0b0YnLUYsNi1RIi5GJ0YvRjJGNUY3RjlGO0Y9Rj8vRkJRJjAuMGVtRicvRkVGaG9GZm5GSEZRRlRGLy1GLDYtUSIrRidGL0YyRjVGN0Y5RjtGPUY/RkFGRC1GIzYqLUZJNiYtRiM2Ji1GTjYkUSIzRidGL0ZRRlRGL0YvRlZGWUZmbkZkb0ZmbkZfcEZRRlRGL0Yv">LCYtSSIuRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiQ3IyIiIkYqISIiLUYkNiQ3IyIiJEYvRis=</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2270" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[51,153,102]" layout="Normal"><Font foreground="[51,153,102]">Poi3 := Poiss_t_nt(BExt, [2,3], false, [[2],[1,2]], 4);
Combinacion_Formal(Poi3, Basis_of_TensorC(BExt[0],BExt[3]));</Font></Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVElUG9pM0YnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKn4mIzg3ODg7fkYnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR0ZMLUkobWZlbmNlZEdGJDYmLUYjNiwtRiM2JS1GNjYtUSomdW1pbnVzMDtGJ0Y5RjtGPkZARkJGREZGRkgvRktRLDAuMjIyMjIyMmVtRicvRk5GWi1JI21uR0YkNiRRIjFGJ0Y5RjktRjY2LVEiLEYnRjlGOy9GP0YxRkBGQkZERkZGSEZKL0ZOUSwwLjMzMzMzMzNlbUYnLUZnbjYkUSIwRidGOUZqbkZgb0ZqbkZgby8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5RjkvJSVvcGVuR1EiW0YnLyUmY2xvc2VHUSJdRidGY29GZm9GOQ==">NyYhIiIiIiFGJEYk</Equation></Text-field>
</Output>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYnLUkjbW9HRiQ2LVEqJnVtaW51czA7RicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjIyMjIyMmVtRicvJSdyc3BhY2VHRkMtRiM2Ki1JKG1mZW5jZWRHRiQ2Ji1GIzYmLUYsNi1RIUYnRi9GMkY1RjdGOUY7Rj1GPy9GQlEsMC4yNzc3Nzc4ZW1GJy9GRUZRLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y0Ri9GLy8lJW9wZW5HUSJbRicvJSZjbG9zZUdRIl1GJy1JJ21zcGFjZUdGJDYmLyUnaGVpZ2h0R1EmMC4wZXhGJy8lJndpZHRoR1EmMC41ZW1GJy8lJmRlcHRoR0Zdby8lKmxpbmVicmVha0dRJWF1dG9GJy1GLDYtUSIuRidGL0YyRjVGN0Y5RjtGPUY/L0ZCUSYwLjBlbUYnL0ZFRmpvRmhuLUZJNiYtRiM2Ki1JI21uR0YkNiRRIjFGJ0YvLUYsNi1RIixGJ0YvRjIvRjZRJXRydWVGJ0Y3RjlGO0Y9Rj9GaW8vRkVRLDAuMzMzMzMzM2VtRictRmFwNiRRIjJGJ0YvRmRwLUZhcDYkUSIzRidGL0ZTRlZGL0YvRlhGZW5GU0ZWRi9GU0ZWRi8=">LCQtSSIuRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiNiQ3IjclIiIiIiIjIiIkISIi</Equation></Text-field>
</Output>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2184" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[255,102,0]" layout="Normal"><Font foreground="[255,102,0]">#------------------------------------------------------------------------#</Font></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Corchete de Poisson de dos elementos en coordenadas</Font></Text-field></Title>
<Group hide-output="false" labelreference="L2205" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">poiss_brack := proc(BE, FT_1::list ,FT_2::list, k1, k2, k3, k4, dimV)
local ii, jj, poiss_res, e_b1, e_b2, poiss_aux, sign_aux, dim_lleg_1, dim_lleg_2, B_lleg:
local B_FT_1, B_FT_2:

<Font foreground="[51,102,255]"># Creo que ya estan todos los importantes (despues revisar)</Font>

sign_aux := 1:

<Font foreground="[51,102,255]">if k1 &lt;&gt; 0 and k2 &lt;&gt; 0 and k3 &lt;&gt; 0 and k4 &lt;&gt; 0 then:</Font>

   B_FT_1 := Basis_of_TensorL(BE[k1], BE[k2]):
   B_FT_2 := Basis_of_TensorL(BE[k3], BE[k4]):

   dim_lleg_1 := binomial(dimV,k1+k3-1):
   dim_lleg_2 := binomial(dimV,k2+k4-1):

   B_lleg := Basis_of_TensorL(BE[k1+k3-1], BE[k2+k4-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>
           
            poiss_aux := Poiss_nt_nt(BE, e_b1, e_b2, dimV):
            poiss_res := poiss_res + Array(poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

<Font foreground="[51,102,255]">elif k1 &lt;&gt; 0 and k2 &lt;&gt; 0 and k3 &lt;&gt; 0 and k4 = 0 then:</Font> 

   B_FT_1 := Basis_of_TensorL(BE[k1], BE[k2]):
   B_FT_2 := BE[k3]:

   dim_lleg_1 := binomial(dimV,k1+k3-1):
   dim_lleg_2 := binomial(dimV,k2-1):

   B_lleg := Basis_of_TensorL(BE[k1+k3-1], BE[k2-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   sign_aux := (-1)^((k1+k2)*k3+1):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>
           
            poiss_aux := Poiss_t_nt(BE, e_b2, true, e_b1, dimV):
            poiss_res := poiss_res + Array(sign_aux*poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

<Font foreground="[51,102,255]">elif k1 &lt;&gt; 0 and k2 &lt;&gt; 0 and k3 = 0 and k4 &lt;&gt; 0 then: </Font>

   B_FT_1 := Basis_of_TensorL(BE[k1], BE[k2]):
   B_FT_2 := BE[k4]:

   dim_lleg_1 := binomial(dimV,k1-1):
   dim_lleg_2 := binomial(dimV,k2+k4-1):

   B_lleg := Basis_of_TensorL(BE[k1-1], BE[k2+k4-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   sign_aux := (-1)^((k1+k2)*k4+1):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>
           
            poiss_aux := Poiss_t_nt(BE, e_b2, false, e_b1, dimV):
            poiss_res := poiss_res + Array(sign_aux*poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

<Font foreground="[51,102,255]">elif k1 &lt;&gt; 0 and k2 = 0 and k3 &lt;&gt; 0 and k4 &lt;&gt; 0 then:</Font> 

   B_FT_1 := BE[k1]:
   B_FT_2 := Basis_of_TensorL(BE[k3], BE[k4]):

   dim_lleg_1 := binomial(dimV,k1+k3-1):
   dim_lleg_2 := binomial(dimV,k4-1):

   B_lleg := Basis_of_TensorL(BE[k1+k3-1], BE[k4-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>
           
            poiss_aux := Poiss_t_nt(BE, e_b1, true, e_b2, dimV):
            poiss_res := poiss_res + Array(poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

<Font foreground="[51,102,255]">elif k1 = 0 and k2 &lt;&gt; 0 and k3 &lt;&gt; 0 and k4 &lt;&gt; 0 then: </Font>

   B_FT_1 := BE[k2]:
   B_FT_2 := Basis_of_TensorL(BE[k3], BE[k4]):

   dim_lleg_1 := binomial(dimV,k3-1):
   dim_lleg_2 := binomial(dimV,k2+k4-1):

   B_lleg := Basis_of_TensorL(BE[k3-1], BE[k2+k4-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>
           
            poiss_aux := Poiss_t_nt(BE, e_b1, false, e_b2, dimV):
            poiss_res := poiss_res + Array(poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

<Font foreground="[51,102,255]">elif k1 &lt;&gt; 0 and k2 = 0 and k3 = 0 and k4 &lt;&gt; 0 then: </Font>

   B_FT_1 := BE[k1]:
   B_FT_2 := BE[k4]:

   dim_lleg_1 := binomial(dimV,k1-1):
   dim_lleg_2 := binomial(dimV,k4-1):

   B_lleg := Basis_of_TensorL(BE[k1-1], BE[k4-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>
           
            poiss_aux := eval_Pois_2b(BE, e_b1, e_b2, dimV, 1):
            poiss_res := poiss_res + Array(poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

<Font foreground="[51,102,255]">elif k1 = 0 and k2 &lt;&gt; 0 and k3 &lt;&gt; 0 and k4 = 0 then: </Font>

   B_FT_1 := BE[k2]:
   B_FT_2 := BE[k3]:

   dim_lleg_1 := binomial(dimV,k2-1):
   dim_lleg_2 := binomial(dimV,k3-1):

   B_lleg := Basis_of_TensorL(BE[k2-1], BE[k3-1]):
   poiss_res := convert(Vector(1 .. (dim_lleg_1 * dim_lleg_2), 0), Array):

   for ii from 1 to nops(FT_1) do:
      for jj from 1 to nops(FT_2) do:
         if FT_1[ii]&lt;&gt;0 and FT_2[jj]&lt;&gt;0 then:
            
            e_b1 := B_FT_1[ii]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_1</Font>
            e_b2 := B_FT_2[jj]: <Font foreground="[255,102,0]"># Identifico el elemento base de la coordenada i de FormT_2</Font>

            poiss_aux := eval_Pois_2b(BE, e_b1, e_b2, dimV, 2):
            poiss_res := poiss_res + Array(poiss_aux*FT_1[ii]*FT_2[jj]):
         fi: 
      od:
   od:
   return convert(poiss_res,list):

fi:

end proc:

</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2206" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" size="14" layout="Heading 2"><Font size="14">Mostrar en pantalla el resultado de un corchete de Poisson</Font></Text-field></Title>
<Group hide-output="false" labelreference="L2276" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Mostrar_Poiss := proc(Vec1, Vec2, Rpoiss, bas1, bas2, bas3)
    local i, v_formal_1, v_formal_2, poiss_formal:

    v_formal_1 := Combinacion_Formal(Vec1, bas1): 
    v_formal_2 := Combinacion_Formal(Vec2, bas2): 
    poiss_formal := Combinacion_Formal(Rpoiss, bas3):

    if poiss_formal &lt;&gt; 0 then:
<Font encoding="UTF-8">       print(v_formal_1, ` \302\273\302\253</Font> ` , v_formal_2,` = `, poiss_formal): 
       print(`            `):
    fi:
end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2275" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Mostrar_Repr_Poiss:=proc(Vec1, Vec2, RepPoiss, bas1, bas2, bas3)
    local i, v_formal_1, v_formal_2, poiss_formal:

    v_formal_1 := Combinacion_Formal(Vec1, bas1): 
    v_formal_2 := Combinacion_Formal(Vec2, bas2): 
    poiss_formal := Vectores_Formal(RepPoiss, bas3):
    if poiss_formal &lt;&gt; [] then:
        <Font encoding="UTF-8">print(v_formal_1, ` \302\273\302\253</Font> ` , v_formal_2,` = `, poiss_formal): 
        print(`            `):
    fi:
end proc:
</Text-field>
</Input>
</Group>
<Group labelreference="L2282" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Rutinas para algebras Cuadraticas</Text-field></Title><Text-field style="Text" foreground="[51,102,255]" layout="Normal"><Font foreground="[51,102,255]">Estos metodos son exclusicamente para algebras de Lie del tipo cuadratica. Se requiere previamente el calculo de </Font></Text-field><Text-field style="Text" foreground="[51,102,255]" layout="Normal"><Font foreground="[51,102,255]">la forma bilineal invariante no degenerada </Font></Text-field>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Forma bilineal invariante</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Evaluar</Font><Font size="12"> </Font></Text-field></Title>
<Group hide-output="false" labelreference="L2296" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># Evalua la forma bilineal Bil_F sobre dos vectores Vec1, Vec2 que representan
# las coordenadas de dos elementos sobre L en la base definida</Font>

Eval_Bil_v := proc(Vec1 , Vec2 , Bil_M::Matrix)
  return evalm(Vec1 &amp;* Bil_M &amp;* Vec2):
end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L2293" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># En este metodo e1 y e2 son dos elementos de BaseExterior[1], ie, vectores de 
# una coordenada: ei = [vi] 
</Font> 
Eval_Bil_b := proc(e1, e2, Bil_M::Matrix)
local v1, v2:
   v1 := Vector(dimL,0): v1[e1[1]]:=1:
   v2 := Vector(dimL,0): v2[e2[1]]:=1:
   return Eval_Bil_v(v1,v2,Bil_M):
end proc:
 </Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L2291" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># Este metodo calcula la B-base de L</Font>

Calcula_B_base := proc(BasL, Bil_M)
local B_res, ii, jj, N, e_aux:

B_res := []:
N := nops(BasL):

for ii from 1 to N do:
   jj := 1:
   while jj &lt;= N do:
      e_aux := Eval_Bil_b(BasL[ii],BasL[jj],Bil_M):<Font foreground="[153,204,0]">
</Font>      if e_aux &lt;&gt; 0 then:
         B_res := [op(B_res),BasL[jj]]:
         jj := N:
      fi:
      jj := jj+1:
   od:
od:
return B_res:
end proc:

Calcula_B_base_cf := proc(BasL, Bil_M)
local B_res, ii, jj, N, e_aux:

B_res := []:
N := nops(BasL):

for ii from 1 to N do:
   jj := 1:
   while jj &lt;= N do:
      e_aux := Eval_Bil_b(BasL[ii],BasL[jj],Bil_M):
      if e_aux &lt;&gt; 0 then:
         B_res := [op(B_res),[1/e_aux,BasL[jj]]]:
         jj := N:
      fi:
      jj := jj+1:
   od:
od:
return B_res:
end proc:
</Text-field>
</Input>
</Group>
<Group labelreference="L2299" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Coord_2_Form := proc(Bil_M,T,BE)
local Res, e_aux, b_pos, b_ele, ii, jj, kk, bas, bas2, N:
bas := BE[1]:
bas2 := Basis_of_TensorC(BE[1],BE[1]);
N := nops(bas):
Res := convert(Vector(1 .. N^2, 0), list): <Font foreground="[153,204,0]"># Coordenadas de la 2-Forma</Font>
for ii from 1 to N do:
   for jj from 1 to N do:
      e_aux := Eval_Bil_b(bas[ii],bas[jj],Bil_M):
      b_ele := bas[ii].bas[jj]: <Font foreground="[153,204,0]"># Respeta la estructura de datos de Basis_of_TensorC</Font>
      b_pos := Find_Element(bas2,b_ele):
      if b_pos &lt;&gt; -1 then Res[b_pos] := Res[b_pos] + e_aux fi:
   od:
od:
return Res:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Bracket auxiliar</Font></Text-field></Title>
<Group hide-output="false" labelreference="L2289" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Brak_aux := proc(u,v,T) local i,j,k,d,w;
d := nops(convert(u,list)):
w := Vector(d,0):
for i from 1 to d do:
   for j from 1 to d do:
      for k from 1 to d do:
         w[k]:=simplify(w[k]+u[i]*v[j]*T[i,j][k]):
      od:
   od:
od:
return w:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">3-Forma Alternate asociada </Font></Text-field></Title>
<Group hide-output="false" labelreference="L2295" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]"># Evalua la 3-forma alternante asociada a Bil_M sobre tres vectores Vec1, Vec2, Vec3
# que representan las coordenadas de tres vectores en la base de L</Font>

Eval_3_Form_v := proc(Vec1, Vec2, Vec3, Bil_M::Matrix, T)
   local corch_aux:
   corch_aux := Brak_aux(Vec1,Vec2,T):
   return Eval_Bil_v(corch_aux, Vec3, Bil_M):
end proc:

<Font foreground="[255,153,0]"># Evalua la 3-forma alternante asociada a Bil_M sobre tres elementos bases e1, e2, e3
# En este metodo e1 y e2 son dos elementos de BaseExterior[1], ie, vectores de 
# una coordenada: ei = [vi]
</Font>
Eval_3_Form_b := proc(e1, e2, e3, Bil_M::Matrix, T)
<Font foreground="[153,204,0]"># Cada ei es un vector de una coordenada, que es la esstructura de BaseExterior[1]</Font>
   local corch_aux, v1, v2, v3:
   v1 := Vector(dimL,0): v1[e1[1]]:=1:
   v2 := Vector(dimL,0): v2[e2[1]]:=1:
   v3 := Vector(dimL,0): v3[e3[1]]:=1:
   return Eval_3_Form_v(v1,v2,v3,Bil_M,T):
end proc:

Coord_3_Form := proc(Bil_M,T,BE)
local Res, e_aux, b_pos, b_ele, ii, jj, kk, bas, bas3, N:
bas := BE[1]:
bas3 := BE[3]:
N := nops(bas):
Res := convert(Vector(1 .. binomial(N,3), 0), list): <Font foreground="[153,204,0]"># Coordenadas de la 3-Forma</Font>
for ii from 1 to N do:
   for jj from ii+1 to N do:
      for kk from jj+1 to N do:
         e_aux := Eval_3_Form_b(bas[ii],bas[jj],bas[kk],Bil_M,T):
         b_ele := [bas[ii][1],bas[jj][1],bas[kk][1]]:
         b_pos := Find_Element(bas3,b_ele):
         if b_pos &lt;&gt; -1 then Res[b_pos] := Res[b_pos] + e_aux fi:
      od:
   od:
od:
return Res:
end proc:
</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="14">Corchete de Super-Poisson asociado</Font></Text-field></Title>
<Group hide-output="false" labelreference="L2297" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Poisson_Bracket := proc(Form1, Form2, k1, k2, Bil_M, BE)
local bas, Bbas, ii, jj, ev_aux, ip_1, ip_2, w_aux, N, Res:
local BD_ini1, BD_fin1, BD_ini2, BD_fin2:

bas := BE[1]:
Bbas := Calcula_B_base(bas,Bil_M):
N := nops(bas): <Font foreground="[153,204,0]"># Dimension del algebra</Font>
Res := convert(Vector(1 .. binomial(N,k1+k2-2), 0), list):

if k1 &gt; 1 and k2 &gt;1 then:
   BD_ini1 := BE[k1]: BD_fin1 := BE[k1-1]:
   BD_ini2 := BE[k2]: BD_fin2 := BE[k2-1]: 

   for ii from 1 to N do:
      for jj from 1 to N do:
         ev_aux := (-1)^(k1+1)*Eval_Bil_b(Bbas[ii], Bbas[jj], Bil_M):
         if ev_aux &lt;&gt; 0 then:

            ip_1 := Int_Prod_Vec_coord_t_v2(Form1, BD_ini1, BD_fin1, bas[ii][1]):
            ip_2 := Int_Prod_Vec_coord_t_v2(Form2, BD_ini2, BD_fin2, bas[jj][1]):

            <Font foreground="[153,204,0]"># print(Form1,bas[ii],` ----&gt; `,ip_1):
            # print(Form2,bas[jj],` ----&gt; `,ip_2):</Font>
         
            w_aux := form_wedge_BE(BE, ip_1, ip_2, k1-1, k2-1, N):
            Res := eval(Res + ev_aux*w_aux):
         
         fi:  
      od:
   od:
elif k1 &gt; 1 then:
   BD_ini1 := BE[k1]: BD_fin1 := BE[k1-1]:
   
   for ii from 1 to N do:
      for jj from 1 to N do:
         ev_aux := (-1)^(k1+1)*Eval_Bil_b(Bbas[ii], Bbas[jj], Bil_M):
         if ev_aux &lt;&gt; 0 then:

            ip_1 := Int_Prod_Vec_coord_t_v2(Form1, BD_ini1, BD_fin1, bas[ii][1]):
            ip_2 := Int_Prod_Vec_coord_t_lin(Form2, bas[jj][1]):

            <Font foreground="[153,204,0]"># print(Form1,bas[ii],` ----&gt; `,ip_1):
            # print(Form2,bas[jj],` ----&gt; `,ip_2):</Font>
         
            w_aux := ip_2*ip_1:
            Res := eval(Res + ev_aux*w_aux):
         
         fi:  
      od:
   od:
elif k2 &gt; 1 then:
   BD_ini2 := BE[k2]: BD_fin2 := BE[k2-1]:
   
   for ii from 1 to N do:
      for jj from 1 to N do:
         ev_aux := Eval_Bil_b(Bbas[ii], Bbas[jj], Bil_M):
         if ev_aux &lt;&gt; 0 then:

            ip_2 := Int_Prod_Vec_coord_t_v2(Form2, BD_ini2, BD_fin2, bas[jj][1]):
            ip_1 := Int_Prod_Vec_coord_t_lin(Form1, bas[ii][1]):

            <Font foreground="[153,204,0]"># print(Form1,bas[ii],` ----&gt; `,ip_1):
            # print(Form2,bas[jj],` ----&gt; `,ip_2):</Font>
         
            w_aux := ip_1*ip_2:
            Res := eval(Res + ev_aux*w_aux):
         
         fi:  
      od:
   od:
fi:
return Res:
  
end proc:</Text-field>
</Input>
</Group>
<Group labelreference="L2300" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
</Section>
</Section>
<Group labelreference="L3495" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[51,102,255]"># ---------------------------------------------------------------
#                         Rutinas Extras
# ---------------------------------------------------------------</Font></Text-field>
</Input>
</Group>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2"><Font size="18">Relaciones de productos</Font></Text-field></Title><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L3510" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Multiplica := proc(u,v,T) local i,j,k,d,w;
d:=nops(convert(u,list)):
w:=Vector(d,0):
for i from 1 to d do:
   for j from 1 to d do:
      for k from 1 to d do:
         w[k]:=simplify(w[k]+u[i]*v[j]*T[i,j][k]):
      od:
   od:
od:
return w:
end proc:
</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3501" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">VerifJacobi := proc(T) local i,j,a,b,c,r,l,dd,TT,m,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for c from 1 to dd do:
         for l from 1 to dd do:
            s:=0:
            for r from 1 to dd do:
               s:=s
                  +T[a,b][r]*T[r,c][l]
                  -T[a,c][r]*T[r,b][l]
                  +T[b,c][r]*T[r,a][l]:
            od:
            if simplify(s)&lt;&gt;0 then cond := cond union {simplify(s) = 0}:fi:
         od:
      od:
   od:
od:

return cond:
end proc:
</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3504" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">VerifAssoc := proc(T) local i,j,a,b,c,r,l,dd,TT,m,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for c from 1 to dd do:
         for l from 1 to dd do:
            s:=0:
            for r from 1 to dd do:
               s:=s
                  +T[a,b][r]*T[r,c][l]
                  -T[b,c][r]*T[a,r][l]:
            od:
            if simplify(s)&lt;&gt;0 then cond := cond union {[a,b,c,simplify(s) = 0]}:fi:
         od:
      od:
   od:
od:

return cond:
end proc:
</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3505" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">VerifLie := proc(T) local i,j,a,b,c,r,l,dd,TT,m,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for c from 1 to dd do:
         cond:=cond union {T[a,b][c]+T[b,a][c]=0}:
         for l from 1 to dd do:
            s:=0:
            for r from 1 to dd do:
               s:=s
                  +T[a,b][r]*T[r,c][l]
                  -T[a,c][r]*T[r,b][l]
                  +T[b,c][r]*T[r,a][l]:
            od:
            if simplify(s)&lt;&gt;0 then cond:=cond union {simplify(s) = 0}:fi:
         od:
      od:
   od:
od:

return cond:
end proc:
</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3497" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Verif_Abel := proc(T) local i,j,a,b,c,dd,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for c from 1 to dd do:
         s := simplify(T[a,b][c]-T[b,a][c]):
         if s &lt;&gt; 0 then:
            cond:=cond union {s=0}:
         fi:
      od:
   od:
od:

return cond:
end proc:

Verif_Anti_Abel := proc(T) local i,j,a,b,c,dd,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for c from 1 to dd do:
         s := simplify(T[a,b][c]+T[b,a][c]):
         if s &lt;&gt; 0 then:
            cond:=cond union {s=0}:
         fi:
      od:
   od:
od:

return cond:
end proc:
</Font></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3509" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Verif_LeftAlt_Law := proc(T) local i,j,a,b,r,l,dd,TT,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for l from 1 to dd do:
         s:=0:
         for r from 1 to dd do:
            s:=s
               +T[a,a][r]*T[r,b][l]
               -T[a,b][r]*T[a,r][l]:
         od:
         if simplify(s)&lt;&gt;0 then cond := cond union {[a,a,b,simplify(s) = 0]}:fi:
       od:
    od:
od:

return cond:
end proc:

Verif_RightAlt_Law := proc(T) local i,j,a,b,r,l,dd,TT,cond,s:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for l from 1 to dd do:
         s:=0:
         for r from 1 to dd do:
            s:=s
               +T[a,b][r]*T[r,b][l]
               -T[b,b][r]*T[a,r][l]:
         od:
         if simplify(s)&lt;&gt;0 then cond := cond union {[a,b,b,simplify(s) = 0]}:fi:
       od:
    od:
od:

return cond:
end proc:
</Font></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L3511" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[0,128,128]" layout="Normal"><Font foreground="[0,128,128]">Verif_Malcev := proc(T) 
local a,b,c,r,s,t,l,dd,m,cond, sum1, sum2:
dd:=nops(T[1,2]):
cond:={}:
for a from 1 to dd do:
   for b from 1 to dd do:
      for c from 1 to dd do:
         for t from 1 to dd do:
            sum1 := 0:
            sum2 := 0:
            for s from 1 to dd do:
               for r from 1 to dd do:
                  sum1 := sum1
                          +T[a,b][r]*T[r,c][s]*T[s,a][t]
                          +T[b,c][r]*T[r,a][s]*T[s,a][t]
                          +T[c,a][r]*T[r,b][s]*T[s,a][t]:
                  sum2 := sum2</Font><Font foreground="[120,0,14]">
</Font><Font foreground="[0,128,128]">              +T[a,b][r]*T[a,c][s]*T[r,s][t]
                          +T[a,c][r]*T[b,r][s]*T[s,a][t]
                          +T[a,c][r]*T[r,a][s]*T[s,b][t]:
               od:
            od:
            if simplify(sum1 - sum2 )&lt;&gt;0 then cond := cond union {[a,b,c,simplify(sum1 - sum2) = 0]}:fi:
         od:
      od:
   od:
od:

return cond:
end proc:
</Font></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3507" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" foreground="[0,128,128]" layout="Normal"><Font foreground="[255,153,0]"># Verifica la compatibilidad entre un producto asociativo y un corchete de Lie
# Ta = Tabla de multiplicar de un producto asociativo
# Tl = Tabla de multiplicar de un corchete de Lie</Font><Font foreground="[0,128,128]">

Verif_comp_AsocLie := proc(Ta,Tl) local i,j,k,r,s,dim,cond,sum:
dim := nops(Ta[1,2]):
cond:={}:
if dim = nops(Tl[1,2]) then:
   for i from 1 to dim do:
      for j from 1 to dim do:
         for k from 1 to dim do:
            for s from 1 to dim do:
               sum := 0:
               for r from 1 to dim do:
                  sum := sum
                         +Ta[j,k][r]*Tl[i,r][s]
                         -Tl[i,j][r]*Ta[r,k][s]
                         -Tl[i,k][r]*Ta[j,r][s]:
               od:
               if simplify(sum) &lt;&gt; 0 then cond := cond union {simplify(sum) = 0}: fi:
            od:
         od:
      od:
   od:
else:
   print(`Error en dimensiones de tablas`):
fi: 

return cond:
end proc:</Font></Text-field>
</Input>
</Group></Presentation-Block>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Derivaciones</Text-field></Title><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L3508" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Derivaciones_T := proc(T,z) local x,i,j,l,n,var,X,ecu,lizq,lder,M,sol,vi,vj:
n := nops(T[1,2]):
var := [seq(seq(x[i,j],j=1..n),i=1..n)]:
X := Matrix(n,n,var):
ecu := []:

for i from 1 to n do:
  for j from 1 to n do:
    lizq := X.Vector(T[i,j]):
    vi := Vector(n,0):  vi[i]:=1:
    vj := Vector(n,0):  vj[j]:=1:
    lder := Multiplica(Column(X,i),vj,T)+Multiplica(vi,Column(X,j),T):
    ecu := [op(ecu), seq(lizq[l]=lder[l],l=1..n)]:
  od:
od:

M:=GenerateMatrix(ecu,var)[1]:
sol:=NullSpace(M):
print(&quot;Dim=&quot;,nops(sol)):
M:=Matrix(n,n,0):
for i from 1 to nops(sol) do:
   M := M + z[i]*Matrix(n,n,convert(sol[i],list)):
od:
return M:
end proc:

# ------------------------------------------------------------------------ #

Basis_Deriv_T := proc(T) local x,i,j,l,n,var,X,ecu,lizq,lder,M,sol,vi,vj,Basis_d:
n := nops(T[1,2]):
var := [seq(seq(x[i,j],j=1..n),i=1..n)]:
X := Matrix(n,n,var):
ecu := []:

for i from 1 to n do:
  for j from 1 to n do:
    lizq := X.Vector(T[i,j]):
    vi := Vector(n,0):  vi[i]:=1:
    vj := Vector(n,0):  vj[j]:=1:
    lder := Multiplica(Column(X,i),vj,T)+Multiplica(vi,Column(X,j),T):
    ecu := [op(ecu), seq(lizq[l]=lder[l],l=1..n)]:
  od:
od:

M:=GenerateMatrix(ecu,var)[1]:
sol:=NullSpace(M):
Basis_d := []:
for i from 1 to nops(sol) do:
   Basis_d := [op(Basis_d),Matrix(n,n,convert(sol[i],list))]:
od:
return Basis_d:
end proc:
</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L3517" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Derivaciones_Int := proc(T,z) local k,i,j,n,M,A:
n:=nops(T[1,2]):

for k from 1 to n do:
   A[k] := matrix(n,n,0):
   for i from 1 to n do:
      for j from 1 to n do:
         if j&lt;k then: 
            A[k][i,j] :=-T[j,k][i]:
         fi:
         if j&gt;k then:
            A[k][i,j] := T[k,j][i]:
         fi:
      od:
   od:
od:

A := BaseMat(convert(A,list)):
print(&quot;Dim=&quot;,nops(A)):
M := matrix(n,n,0):

for i from 1 to nops(A) do:
   M := evalm(M+z||i*A[i]):
od:

return evalm(M):
end proc:

# ------------------------------------------------------------------------ #

Basis_Deriv_Int := proc(T) local k,i,j,n,M,A,Basis_di:
n:=nops(T[1,2]):

for k from 1 to n do:
   A[k] := matrix(n,n,0):
   for i from 1 to n do:
      for j from 1 to n do:
         if j&lt;k then: 
            A[k][i,j] :=-T[j,k][i]:
         fi:
         if j&gt;k then:
            A[k][i,j] := T[k,j][i]:
         fi:
      od:
   od:
od:

Basis_di := BaseMat(convert(A,list)):
return Basis_di
end proc:</Text-field>
</Input>
</Group></Presentation-Block>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Morfismo</Text-field></Title>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Verificacion</Text-field></Title>
<Group hide-input="false" hide-output="false" labelreference="L3500" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font foreground="[255,153,0]" encoding="UTF-8"># Verifica si una transformaci\303\263n lineal es un morfismo de algebras
</Font><Font foreground="[255,153,0]"># Parametros:
<Font encoding="UTF-8"># M = Matriz de la transformaci\303\263n lineal entre dos algebras A1 y A2
</Font># T1 = Tabla de multiplicar de A1
# T2 = Tabla de multiplicar de A2</Font>

Verif_morfismo := proc(M,T1,T2) local i,j,k,n,cond,s,v,w,E1,E2:
n := RowDimension(M):
cond := {}:
for i from 1 to n do:
   for j from 1 to n do:
      
      v := convert(Column(M,i),list):
      w := convert(Column(M,j),list):

      E1 := Multiplica(v,w,T2):
      E2 := M.Vector(T1[i,j]):

      for k from 1 to nops(E1) do:
         s := simplify(E1[k]-E2[k]):
         if s &lt;&gt; 0 then:
            cond:=cond union {[i,j,s=0]}:
         fi:
      od:
   od:
od:

return cond:
end proc:</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Cambio de Base</Text-field></Title>
<Group hide-input="false" hide-output="false" labelreference="L3502" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Cambio:=proc(P,T) local i,j,TT,v,w,r,n:
n:=RowDimension(P):

for i from 1 to n do:
   for j from 1 to n do:
      v:=convert(Column(P,i),list); 
      w:=convert(Column(P,j),list); 
      r:=P^(-1).Vector(Multiplica(v,w,T)):

      TT[i,j]:=convert(r,list):
   od:
od:
return eval(TT):
end proc:
</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L3506" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Cambio_inv:=proc(P,T) local i,j,TT,v,w,r,n:
n:=RowDimension(P):

for i from 1 to n do:
   for j from 1 to n do:
      v:=convert(Column(P^(-1),i),list); 
      w:=convert(Column(P^(-1),j),list); 
      r:=P.Vector(Multiplica(v,w,T)):

      TT[i,j]:=convert(r,list):
   od:
od:
return eval(TT):
end proc:</Text-field>
</Input>
</Group>
<Group labelreference="L3512" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Equation executable="true" style="2D Input" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEhRicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkMvJStleGVjdXRhYmxlR0Y0Ri8=</Equation></Text-field>
</Input>
</Group>
</Section>
</Section>
</Worksheet>